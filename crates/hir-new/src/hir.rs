mod debug_dump;
mod ded;
mod dir;
mod expr;
mod lower;
mod name;
mod pat;
mod phrase;
mod sort_ref;
mod stmt;

#[cfg(test)]
mod tests;

use core::fmt;
use std::{hash::BuildHasherDefault, sync::Arc};

use base_db::FileId;
use la_arena::{Arena, Idx};
use rustc_hash::FxHasher;
use syntax::{ast, AstNode, AstPtr};

use crate::{ast_map::FileAstId, db::HirNewDatabase, InFile};

pub use self::{
    debug_dump::{DebugDump, DebugDumper},
    ded::Ded,
    dir::Dir,
    expr::Expr,
    name::{AsName, Name, NameOrWildcard},
    pat::Pat,
    phrase::{Phrase, PhraseId},
    sort_ref::SortRef,
    stmt::{
        Assertion, ClosedAssertion, DefKind, Definition, DomainDeclaration, FileImport,
        FunctionSymbol, Module, ModuleExtension, ModuleImport, Param, SortAlias,
    },
};

pub type FxBiMap<L, R> = bimap::BiHashMap<L, R, BuildHasherDefault<FxHasher>>;

#[derive(Debug, Eq, PartialEq)]
pub struct FileHir {
    file_id: FileId,
    top_level: Vec<ModuleStmt>,
    data: HirData, // generated by hir_maps! below
}

impl FileHir {
    fn empty(file_id: FileId) -> Self {
        Self {
            file_id,
            top_level: Vec::new(),
            data: HirData::default(),
        }
    }

    pub(crate) fn file_hir_with_source_map_query(
        db: &dyn HirNewDatabase,
        file_id: FileId,
    ) -> (Arc<FileHir>, Arc<SourceMap>) {
        let file = db.parse(file_id).tree();
        let ctx = lower::Ctx::new(db, file_id);
        let (hir, map) = ctx.lower_file(file);
        (Arc::new(hir), Arc::new(map))
    }

    pub(crate) fn debug_dump_query(db: &dyn HirNewDatabase, file_id: FileId) -> String {
        let (hir, source_map) = db.file_hir_with_source_map(file_id);
        let mut buf = String::new();

        let mut dd = DebugDumper::new(&hir, &source_map, &mut buf, db);
        hir.debug_dump(&mut dd).unwrap();
        buf
    }
}

impl DebugDump for FileHir {
    fn debug_dump(&self, dd: &mut DebugDumper) -> fmt::Result {
        for stmt in &self.top_level {
            stmt.debug_dump(dd)?;
        }
        Ok(())
    }
}

#[derive(Debug, PartialEq, Eq)]
pub struct SourceMap {
    file_id: FileId,
    ast_id_map: Arc<crate::ast_map::AstIdMap>,
    hir_map: HirAstMap, // generated by hir_maps! below
}

impl SourceMap {
    fn empty(file_id: FileId, ast_id_map: Arc<crate::ast_map::AstIdMap>) -> Self {
        Self {
            file_id,
            ast_id_map,
            hir_map: HirAstMap::default(),
        }
    }
}

pub trait HasHir {
    type Hir: HirNode;

    fn hir(&self, source_map: &SourceMap) -> Option<Idx<Self::Hir>>;

    fn file_id(&self) -> FileId;
}

pub type Source<N> = InFile<AstPtr<N>>;

pub trait HirNode: Sized {
    type Ast: AstNode;

    fn source(id: Idx<Self>, source_map: &SourceMap) -> Option<Source<Self::Ast>>;

    fn node(id: Idx<Self>, hir: &FileHir) -> &Self;

    fn alloc(self, hir: &mut FileHir) -> Idx<Self>;

    fn record_source(id: Idx<Self>, file_ast_id: FileAstId<Self::Ast>, source_map: &mut SourceMap);
}

pub trait Get {
    type Output<'a>;

    fn get(self, hir: &FileHir) -> Self::Output<'_>;
}

impl<T> Get for &T
where
    T: Get + Copy,
{
    type Output<'a> = <T as Get>::Output<'a>;

    fn get(self, hir: &FileHir) -> Self::Output<'_> {
        (*self).get(hir)
    }
}

impl FileHir {
    pub fn get<G: Get>(&self, id: G) -> <G as Get>::Output<'_> {
        id.get(self)
    }
}

macro_rules! hir_maps {
	(@inner $({ ast: $ast: ty, hir: $hir: ty, arena: $arena: ident}),*) => {
		#[derive(Default, Debug, Eq, PartialEq)]
		struct HirAstMap {
			$(
				$arena: FxBiMap<FileAstId<$ast>, Idx<$hir>>,
			)*
		}

		#[derive(Default, Debug, Eq, PartialEq)]
		struct HirData {
			$(
				$arena: Arena<$hir>,
			)*
		}

		$(
			impl HasHir for Source<$ast> {
				type Hir = $hir;

				fn hir(&self, source_map: &SourceMap) -> Option<Idx<Self::Hir>> {
					source_map
						.hir_map
						.$arena
						.get_by_left(&source_map.ast_id_map.ast_id_ptr(&self.value))
						.copied()
				}

				fn file_id(&self) -> FileId {
					self.file_id
				}
			}

			impl HirNode for $hir {
				type Ast = $ast;

				fn source(id: Idx<Self>, source_map: &SourceMap) -> Option<Source<$ast>> {
					let ast_id = source_map.hir_map.$arena.get_by_right(&id)?;
					Some(InFile::new(
						source_map.file_id,
						source_map.ast_id_map.get(*ast_id),
					))
				}

				fn node(id: Idx<Self>, hir: &FileHir) -> &Self {
					&hir.data.$arena[id]
				}

                fn alloc(self, hir: &mut FileHir) -> Idx<Self> {
                    hir.data.$arena.alloc(self)
                }

                fn record_source(id: Idx<Self>, file_ast_id: FileAstId<$ast>, source_map: &mut SourceMap) {
                    source_map.hir_map.$arena.insert(
                        file_ast_id,
                        id,
                    );
                }
			}


            paste::paste! {
                pub type [<$hir Id>] = ::la_arena::Idx<$hir>;
            }

            impl ::std::ops::Index<::la_arena::Idx<$hir>> for FileHir {
                type Output = $hir;

                fn index(&self, index: ::la_arena::Idx<$hir>) -> &Self::Output {
                    &self.data.$arena[index]
                }
            }

            impl Get for ::la_arena::Idx<$hir> {
                type Output<'a> = &'a $hir;

                fn get(self, hir: &FileHir) -> Self::Output<'_> {
                    &hir.data.$arena[self]
                }
            }

		)*
	};
    ($(
		$ast:ty => $hir: ty | $arena: ident
	),* $(,)?) => {
		hir_maps!(@inner $({ ast: $ast, hir: $hir, arena: $arena }),*);
	};
}

hir_maps! {
    ast::ModuleDir          => Module               | modules,
    ast::ExtendModuleDir    => ModuleExtension      | module_exts,
    ast::TermSymbol         => FunctionSymbol       | func_symbols,
    ast::DefineSortDir      => SortAlias            | sort_aliases,
    ast::LoadDir            => FileImport           | file_imports,
    ast::OpenDir            => ModuleImport         | module_imports,
    ast::Domain             => DomainDeclaration    | domains,
    ast::AssertDir          => Assertion            | assertions,
    ast::AssertClosedDir    => ClosedAssertion      | closed_assertions,
    ast::Dir                => Dir                  | dirs,
    ast::Pat                => Pat                  | pats,
    ast::Sort               => SortRef              | sort_refs,
    ast::DefineDir          => Definition           | definitions,
    ast::Expr               => Expr                 | exprs,
    ast::Ded                => Ded                  | deds,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]
pub enum ModuleStmt {
    Module(Idx<Module>),
    ModuleExtension(Idx<ModuleExtension>),
    FunctionSymbol(Idx<FunctionSymbol>),
    SortAlias(Idx<SortAlias>),
    FileImport(Idx<FileImport>),
    ModuleImport(Idx<ModuleImport>),
    DomainDeclaration(Idx<DomainDeclaration>),
    Assertion(Idx<Assertion>),
    ClosedAssertion(Idx<ClosedAssertion>),
    Dir(Idx<Dir>),
    Definition(Idx<Definition>),
}

macro_rules! impl_from_idx {
    ($($v: ident),+ for $t: ty) => {
        $(
            impl From<Idx<$v>> for $t {
                fn from(idx: Idx<$v>) -> Self {
                    Self::$v(idx)
                }
            }
        )+
    };
}

macro_rules! impl_debug_dump {
    (delegate $($e: ident),* for $t: ty) => {
        impl $crate::hir::DebugDump for $t {
            fn debug_dump(
                &self,
                dd: &mut $crate::hir::debug_dump::DebugDumper<'_>,
            ) -> ::core::fmt::Result {
                match self {
                    $(
                        Self::$e(v) => {
                            v.debug_dump(dd)?;
                        }
                    )+
                }
                Ok(())
            }
        }
    };
    ($($e: ident),* for $t: ty) => {
        impl $crate::hir::DebugDump for $t {
            fn debug_dump(
                &self,
                dd: &mut $crate::hir::debug_dump::DebugDumper<'_>,
            ) -> ::core::fmt::Result {
                match self {
                    $(
                        Self::$e(idx) => {
                            dd.hir[*idx].debug_dump(dd)?;
                        }
                    )+
                }
                Ok(())
            }
        }
    };
    (delegate ids $($e: ident),* for $t: ty) => {
        impl $crate::hir::DebugDump for $t {
            fn debug_dump(
                &self,
                hir: &$crate::hir::FileHir,
                source_map: &$crate::hir::SourceMap,
                f: &mut dyn ::core::fmt::Write,
            ) -> ::core::fmt::Result {
                match self {
                    $(
                        Self::$e(idx) => {
                            hir[*idx].debug_dump(hir, source_map, f)?;
                        }
                    )+
                }
                Ok(())
            }
        }
    };
}

pub(crate) use impl_debug_dump;

macro_rules! impl_macros {
    ($(,)? ; $($e: ident),+ for $t: ty) => {};
    ($m1: ident ! $(, $rest: ident !)* ; $($e: ident),+ for $t: ty) => {
        $m1!($($e),+ for $t);
        impl_macros!($($rest!),* ; $($e),+ for $t);
    };
}

impl_macros! {
    impl_from_idx!, impl_debug_dump!;

    Module,
    ModuleExtension,
    FunctionSymbol,
    SortAlias,
    FileImport,
    ModuleImport,
    DomainDeclaration,
    Assertion,
    ClosedAssertion,
    Dir,
    Definition for ModuleStmt
}
