//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(non_snake_case, dead_code, unused_imports)]
use crate::{
    SyntaxNode, SyntaxToken, SyntaxKind::{self, *},
    ast::{self, AstNode, AstChildren, support},
    T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Fake {
    pub(crate) syntax: SyntaxNode,
}
impl Fake {
    pub fn dtry_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dtry])
    }
    pub fn dlet_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dlet])
    }
    pub fn dcheck_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dcheck])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Identifier {
    pub(crate) syntax: SyntaxNode,
}
impl Identifier {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaIdent {
    pub(crate) syntax: SyntaxNode,
}
impl MetaIdent {
    pub fn single_quote_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['\''])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Unit {
    pub(crate) syntax: SyntaxNode,
}
impl Unit {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypedParam {
    pub(crate) syntax: SyntaxNode,
}
impl TypedParam {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OpAnnotatedParam {
    pub(crate) syntax: SyntaxNode,
}
impl OpAnnotatedParam {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn OP_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![OP])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Wildcard {
    pub(crate) syntax: SyntaxNode,
}
impl Wildcard {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![_])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixBinding {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixBinding {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VarSort {
    pub(crate) syntax: SyntaxNode,
}
impl VarSort {
    pub fn single_quote_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['\''])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentSort {
    pub(crate) syntax: SyntaxNode,
}
impl IdentSort {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundSort {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundSort {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn sorts(&self) -> AstChildren<Sort> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DirStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DirStmt {
    pub fn dir(&self) -> Option<Dir> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PhraseStmt {
    pub(crate) syntax: SyntaxNode,
}
impl PhraseStmt {
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructureNameDef {
    pub(crate) syntax: SyntaxNode,
}
impl StructureNameDef {
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstantConstructor {
    pub(crate) syntax: SyntaxNode,
}
impl ConstantConstructor {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundConstructor {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundConstructor {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn maybe_tagged_sort_decl(&self) -> Option<MaybeTaggedSortDecl> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MaybeTaggedSortDecl {
    pub(crate) syntax: SyntaxNode,
}
impl MaybeTaggedSortDecl {
    pub fn tag(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructureDef {
    pub(crate) syntax: SyntaxNode,
}
impl StructureDef {
    pub fn structure_name_def(&self) -> Option<StructureNameDef> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn structure_constructors(&self) -> AstChildren<StructureConstructor> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DatatypeStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DatatypeStmt {
    pub fn datatype_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![datatype])
    }
    pub fn structure_def(&self) -> Option<StructureDef> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructureStmt {
    pub(crate) syntax: SyntaxNode,
}
impl StructureStmt {
    pub fn structure_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![structure])
    }
    pub fn structure_def(&self) -> Option<StructureDef> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DatatypesStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DatatypesStmt {
    pub fn datatypes_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![datatypes])
    }
    pub fn structure_defs(&self) -> AstChildren<StructureDef> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StructuresStmt {
    pub(crate) syntax: SyntaxNode,
}
impl StructuresStmt {
    pub fn structures_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![structures])
    }
    pub fn structure_defs(&self) -> AstChildren<StructureDef> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DomainDir {
    pub(crate) syntax: SyntaxNode,
}
impl DomainDir {
    pub fn domain_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![domain])
    }
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DomainsDir {
    pub(crate) syntax: SyntaxNode,
}
impl DomainsDir {
    pub fn domains_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![domains])
    }
    pub fn sort_decls(&self) -> AstChildren<SortDecl> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoadDir {
    pub(crate) syntax: SyntaxNode,
}
impl LoadDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn load_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![load])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertClosedDir {
    pub(crate) syntax: SyntaxNode,
}
impl AssertClosedDir {
    pub fn assert_star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assert *])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExtendModuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl ExtendModuleDir {
    pub fn extend_module_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![extend - module])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OpenDir {
    pub(crate) syntax: SyntaxNode,
}
impl OpenDir {
    pub fn open_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![open])
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssociativityDir {
    pub(crate) syntax: SyntaxNode,
}
impl AssociativityDir {
    pub fn left_assoc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![left - assoc])
    }
    pub fn right_assoc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![right - assoc])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixModuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl InfixModuleDir {
    pub fn module_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![module])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixModuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixModuleDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn module_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![module])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundSortDecl {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundSortDecl {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn sort_decls(&self) -> AstChildren<SortDecl> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixConstantDeclare {
    pub(crate) syntax: SyntaxNode,
}
impl InfixConstantDeclare {
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixConstantDeclare {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixConstantDeclare {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn prefix_declare_symbols(&self) -> Option<PrefixDeclareSymbols> {
        support::child(&self.syntax)
    }
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDeclareDir {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixDeclareDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn prefix_declare_symbols(&self) -> Option<PrefixDeclareSymbols> {
        support::child(&self.syntax)
    }
    pub fn prefix_sort_vars_decl(&self) -> Option<PrefixSortVarsDecl> {
        support::child(&self.syntax)
    }
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn sort_decls(&self) -> AstChildren<SortDecl> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
    pub fn prefix_declare_attrs(&self) -> Option<PrefixDeclareAttrs> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixSortVarsDecl {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixSortVarsDecl {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ident_sorts(&self) -> AstChildren<IdentSort> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDeclareAttrs {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixDeclareAttrs {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn declare_attrs(&self) -> AstChildren<DeclareAttr> {
        support::children(&self.syntax)
    }
    pub fn input_transform_decl(&self) -> Option<InputTransformDecl> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixSingleSymbol {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixSingleSymbol {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixMultiSymbols {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixMultiSymbols {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeclareAttr {
    pub(crate) syntax: SyntaxNode,
}
impl DeclareAttr {
    pub fn left_assoc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![left - assoc])
    }
    pub fn right_assoc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![right - assoc])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InputTransformDecl {
    pub(crate) syntax: SyntaxNode,
}
impl InputTransformDecl {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
    pub fn infer_or_expr(&self) -> Option<InferOrExpr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixDeclareDir {
    pub(crate) syntax: SyntaxNode,
}
impl InfixDeclareDir {
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort_vars_decl(&self) -> Option<SortVarsDecl> {
        support::child(&self.syntax)
    }
    pub fn func_sorts(&self) -> Option<FuncSorts> {
        support::child(&self.syntax)
    }
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn return_sort(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
    pub fn declare_attrs(&self) -> Option<DeclareAttrs> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SortVarsDecl {
    pub(crate) syntax: SyntaxNode,
}
impl SortVarsDecl {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ident_sorts(&self) -> AstChildren<IdentSort> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FuncSorts {
    pub(crate) syntax: SyntaxNode,
}
impl FuncSorts {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn sort_decls(&self) -> AstChildren<SortDecl> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeclareAttrs {
    pub(crate) syntax: SyntaxNode,
}
impl DeclareAttrs {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn declare_attrs(&self) -> AstChildren<DeclareAttr> {
        support::children(&self.syntax)
    }
    pub fn input_transform_decl(&self) -> Option<InputTransformDecl> {
        support::child(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixDefineDir {
    pub(crate) syntax: SyntaxNode,
}
impl InfixDefineDir {
    pub fn private_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![private])
    }
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn define_name(&self) -> Option<DefineName> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDefine {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixDefine {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn define_name(&self) -> Option<DefineName> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDefineBlocks {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixDefineBlocks {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn prefix_define_blocks(&self) -> AstChildren<PrefixDefineBlock> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixDefineBlock {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixDefineBlock {
    pub fn define_proc(&self) -> Option<DefineProc> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineNamedPattern {
    pub(crate) syntax: SyntaxNode,
}
impl DefineNamedPattern {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    pub fn list_pat(&self) -> Option<ListPat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineProc {
    pub(crate) syntax: SyntaxNode,
}
impl DefineProc {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn args(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListPat {
    pub(crate) syntax: SyntaxNode,
}
impl ListPat {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixAssertDir {
    pub(crate) syntax: SyntaxNode,
}
impl InfixAssertDir {
    pub fn assert_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assert])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixAssertDir {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixAssertDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn assert_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assert])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixRuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl InfixRuleDir {
    pub fn primitive_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![primitive - method])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn maybe_wildcard_typed_params(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixRuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixRuleDir {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn primitive_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![primitive - method])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn maybe_wildcard_typed_params(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExpandInputDir {
    pub(crate) syntax: SyntaxNode,
}
impl ExpandInputDir {
    pub fn expand_input_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![expand - input])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn expander(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineSortDir {
    pub(crate) syntax: SyntaxNode,
}
impl DefineSortDir {
    pub fn define_sort_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define - sort])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprPhrase {
    pub(crate) syntax: SyntaxNode,
}
impl ExprPhrase {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DedPhrase {
    pub(crate) syntax: SyntaxNode,
}
impl DedPhrase {
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IdentExpr {
    pub fn maybe_typed_param(&self) -> Option<MaybeTypedParam> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralExpr {
    pub fn literal(&self) -> Option<Literal> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitExpr {
    pub(crate) syntax: SyntaxNode,
}
impl UnitExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TermVarExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TermVarExpr {
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![?])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CheckExpr {
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn check_arms(&self) -> AstChildren<CheckArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaExpr {
    pub fn lambda_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![lambda])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn maybe_wildcard_typed_params(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ApplicationExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ApplicationExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ListExpr {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MethodExpr {
    pub fn method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![method])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn maybe_wildcard_typed_params(&self) -> AstChildren<MaybeWildcardTypedParam> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LetExpr {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_parts(&self) -> AstChildren<LetPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetRecExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LetRecExpr {
    pub fn letrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![letrec])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_rec_parts(&self) -> AstChildren<LetRecPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TryExpr {
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn try_arms(&self) -> AstChildren<TryArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CellExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CellExpr {
    pub fn cell_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![cell])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl SetExpr {
    pub fn set_bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![set!])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefExpr {
    pub(crate) syntax: SyntaxNode,
}
impl RefExpr {
    pub fn ref_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ref])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}
impl WhileExpr {
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MakeVectorExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MakeVectorExpr {
    pub fn make_vector_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![make - vector])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VectorSubExpr {
    pub(crate) syntax: SyntaxNode,
}
impl VectorSubExpr {
    pub fn vector_sub_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![vector - sub])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VectorSetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl VectorSetExpr {
    pub fn vector_set_bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![vector - set!])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SeqExpr {
    pub(crate) syntax: SyntaxNode,
}
impl SeqExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn seq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![seq])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AndExpr {
    pub(crate) syntax: SyntaxNode,
}
impl AndExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ampamp_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![&&])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrExpr {
    pub(crate) syntax: SyntaxNode,
}
impl OrExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pipepipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![||])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MapExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MapExpr {
    pub fn pipe_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["|{"])
    }
    pub fn map_bindings(&self) -> AstChildren<MapBinding> {
        support::children(&self.syntax)
    }
    pub fn curly_pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}|"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardExpr {
    pub(crate) syntax: SyntaxNode,
}
impl WildcardExpr {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![_])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixCheckExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixCheckExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn check_clauses(&self) -> AstChildren<CheckClause> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaIdentExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MetaIdentExpr {
    pub fn meta_ident(&self) -> Option<MetaIdent> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckArm {
    pub(crate) syntax: SyntaxNode,
}
impl CheckArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckClause {
    pub(crate) syntax: SyntaxNode,
}
impl CheckClause {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixLetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixLetExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn prefix_bindings(&self) -> AstChildren<PrefixBinding> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetPart {
    pub(crate) syntax: SyntaxNode,
}
impl LetPart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixLetRecExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixLetRecExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn letrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![letrec])
    }
    pub fn prefix_bindings(&self) -> AstChildren<PrefixBinding> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetRecPart {
    pub(crate) syntax: SyntaxNode,
}
impl LetRecPart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixMatchExpr {
    pub(crate) syntax: SyntaxNode,
}
impl InfixMatchExpr {
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<MatchArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixMatchExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixMatchExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn clauses(&self) -> AstChildren<MatchClause> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}
impl MatchArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchClause {
    pub(crate) syntax: SyntaxNode,
}
impl MatchClause {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryArm {
    pub(crate) syntax: SyntaxNode,
}
impl TryArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixTryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixTryExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn exprs(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MapBinding {
    pub(crate) syntax: SyntaxNode,
}
impl MapBinding {
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallDed {
    pub(crate) syntax: SyntaxNode,
}
impl MethodCallDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn apply_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![apply - method])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BangMethodCallDed {
    pub(crate) syntax: SyntaxNode,
}
impl BangMethodCallDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![!])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl AssumeDed {
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedAssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl NamedAssumeDed {
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn assume_parts(&self) -> AstChildren<AssumePart> {
        support::children(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ProofByContraDed {
    pub(crate) syntax: SyntaxNode,
}
impl ProofByContraDed {
    pub fn suppose_absurd_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![suppose - absurd])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GeneralizeOverDed {
    pub(crate) syntax: SyntaxNode,
}
impl GeneralizeOverDed {
    pub fn generalize_over_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![generalize - over])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PickAnyDed {
    pub(crate) syntax: SyntaxNode,
}
impl PickAnyDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pick_any_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick - any])
    }
    pub fn maybe_typed_params(&self) -> AstChildren<MaybeTypedParam> {
        support::children(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WithWitnessDed {
    pub(crate) syntax: SyntaxNode,
}
impl WithWitnessDed {
    pub fn with_witness_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![with - witness])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PickWitnessDed {
    pub(crate) syntax: SyntaxNode,
}
impl PickWitnessDed {
    pub fn pick_witness_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick - witness])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PickWitnessesDed {
    pub(crate) syntax: SyntaxNode,
}
impl PickWitnessesDed {
    pub fn pick_witnesses_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick - witnesses])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InductDed {
    pub(crate) syntax: SyntaxNode,
}
impl InductDed {
    pub fn by_induction_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![by - induction])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn restricted_match_deds(&self) -> AstChildren<RestrictedMatchDed> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CasesDed {
    pub(crate) syntax: SyntaxNode,
}
impl CasesDed {
    pub fn datatype_cases_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![datatype - cases])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn on_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![on])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn restricted_match_deds(&self) -> AstChildren<RestrictedMatchDed> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConcludeDed {
    pub(crate) syntax: SyntaxNode,
}
impl ConcludeDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn conclude_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![conclude])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferBlockDed {
    pub(crate) syntax: SyntaxNode,
}
impl InferBlockDed {
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn begin_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![begin])
    }
    pub fn maybe_named_inferences(&self) -> AstChildren<MaybeNamedInference> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn end_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![end])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SeqDed {
    pub(crate) syntax: SyntaxNode,
}
impl SeqDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dseq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dseq])
    }
    pub fn deds(&self) -> AstChildren<Ded> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumePart {
    pub(crate) syntax: SyntaxNode,
}
impl AssumePart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixNamedAssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixNamedAssumeDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixSingleAssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixSingleAssumeDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixAssumeLetDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixAssumeLetDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn assume_let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume - let])
    }
    pub fn prefix_binding(&self) -> Option<PrefixBinding> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestrictedMatchDed {
    pub(crate) syntax: SyntaxNode,
}
impl RestrictedMatchDed {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckDedClause {
    pub(crate) syntax: SyntaxNode,
}
impl CheckDedClause {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixCheckDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixCheckDed {
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<CheckDedArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixCheckDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixCheckDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn check_ded_clauses(&self) -> AstChildren<CheckDedClause> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckDedArm {
    pub(crate) syntax: SyntaxNode,
}
impl CheckDedArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixMatchDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixMatchDed {
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<MatchDedArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixMatchDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixMatchDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dmatch_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dmatch])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn clauses(&self) -> AstChildren<MatchDedClause> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchDedArm {
    pub(crate) syntax: SyntaxNode,
}
impl MatchDedArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchDedClause {
    pub(crate) syntax: SyntaxNode,
}
impl MatchDedClause {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixLetDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixLetDed {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_parts(&self) -> AstChildren<LetPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixLetRecDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixLetRecDed {
    pub fn letrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![letrec])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_rec_parts(&self) -> AstChildren<LetRecPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixLetDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixLetDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dlet_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dlet])
    }
    pub fn prefix_bindings(&self) -> AstChildren<PrefixBinding> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixLetRecDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixLetRecDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dletrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dletrec])
    }
    pub fn prefix_bindings(&self) -> AstChildren<PrefixBinding> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InfixTryDed {
    pub(crate) syntax: SyntaxNode,
}
impl InfixTryDed {
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn try_ded_arms(&self) -> AstChildren<TryDedArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixTryDed {
    pub(crate) syntax: SyntaxNode,
}
impl PrefixTryDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn dtry_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![dtry])
    }
    pub fn deds(&self) -> AstChildren<Ded> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryDedArm {
    pub(crate) syntax: SyntaxNode,
}
impl TryDedArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MaybeNamedInference {
    pub(crate) syntax: SyntaxNode,
}
impl MaybeNamedInference {
    pub fn maybe_wildcard_op_annotated_param(
        &self,
    ) -> Option<MaybeWildcardOpAnnotatedParam> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn infer_or_expr(&self) -> Option<InferOrExpr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MaybeWildcardOpAnnotatedParam {
    pub(crate) syntax: SyntaxNode,
}
impl MaybeWildcardOpAnnotatedParam {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![_])
    }
    pub fn op_annotated_param(&self) -> Option<OpAnnotatedParam> {
        support::child(&self.syntax)
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferFrom {
    pub(crate) syntax: SyntaxNode,
}
impl InferFrom {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn from_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![from])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferBy {
    pub(crate) syntax: SyntaxNode,
}
impl InferBy {
    pub fn by_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![by])
    }
    pub fn on_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![on])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn infer_or_expr(&self) -> Option<InferOrExpr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ByDed {
    pub(crate) syntax: SyntaxNode,
}
impl ByDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn by_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![by])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl IdentPat {
    pub fn maybe_wildcard_typed_param(&self) -> Option<MaybeWildcardTypedParam> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VarPat {
    pub(crate) syntax: SyntaxNode,
}
impl VarPat {
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![?])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaIdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl MetaIdentPat {
    pub fn meta_ident(&self) -> Option<MetaIdent> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralPat {
    pub fn literal(&self) -> Option<Literal> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitPat {
    pub(crate) syntax: SyntaxNode,
}
impl UnitPat {
    pub fn unit(&self) -> Option<Unit> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedPat {
    pub(crate) syntax: SyntaxNode,
}
impl NamedPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn bind_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bind])
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ValOfPat {
    pub(crate) syntax: SyntaxNode,
}
impl ValOfPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn val_of_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![val - of])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListOfPat {
    pub(crate) syntax: SyntaxNode,
}
impl ListOfPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn list_of_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![list - of])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SplitPat {
    pub(crate) syntax: SyntaxNode,
}
impl SplitPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn split_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![split])
    }
    pub fn first(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn second(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn rest(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundPat {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePat {
    pub(crate) syntax: SyntaxNode,
}
impl WherePat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn where_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![where])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SomeThingPat {
    pub(crate) syntax: SyntaxNode,
}
impl SomeThingPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn some_thing(&self) -> Option<SomeThing> {
        support::child(&self.syntax)
    }
    pub fn ident_pat(&self) -> Option<IdentPat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrPat {
    pub(crate) syntax: SyntaxNode,
}
impl OrPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pipepipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![||])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SomeThing {
    pub(crate) syntax: SyntaxNode,
}
impl SomeThing {
    pub fn some_var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - var])
    }
    pub fn some_sent_con_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - sent - con])
    }
    pub fn some_quant_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - quant])
    }
    pub fn some_term_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - term])
    }
    pub fn some_atom_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - atom])
    }
    pub fn some_sentence_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - sentence])
    }
    pub fn some_list_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - list])
    }
    pub fn some_cell_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - cell])
    }
    pub fn some_vector_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - vector])
    }
    pub fn some_proc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - proc])
    }
    pub fn some_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - method])
    }
    pub fn some_symbol_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - symbol])
    }
    pub fn some_table_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - table])
    }
    pub fn some_map_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - map])
    }
    pub fn some_sub_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - sub])
    }
    pub fn some_char_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some - char])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MaybeTypedParam {
    Identifier(Identifier),
    TypedParam(TypedParam),
    OpAnnotatedParam(OpAnnotatedParam),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Sort {
    VarSort(VarSort),
    IdentSort(IdentSort),
    CompoundSort(CompoundSort),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MaybeWildcardTypedParam {
    Wildcard(Wildcard),
    MaybeTypedParam(MaybeTypedParam),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(IdentPat),
    VarPat(VarPat),
    MetaIdentPat(MetaIdentPat),
    LiteralPat(LiteralPat),
    UnitPat(UnitPat),
    NamedPat(NamedPat),
    ValOfPat(ValOfPat),
    ListOfPat(ListOfPat),
    SplitPat(SplitPat),
    ListPat(ListPat),
    CompoundPat(CompoundPat),
    WherePat(WherePat),
    SomeThingPat(SomeThingPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Phrase {
    ExprPhrase(ExprPhrase),
    DedPhrase(DedPhrase),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    DirStmt(DirStmt),
    PhraseStmt(PhraseStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Dir {
    DomainDir(DomainDir),
    DomainsDir(DomainsDir),
    LoadDir(LoadDir),
    AssertClosedDir(AssertClosedDir),
    ExtendModuleDir(ExtendModuleDir),
    OpenDir(OpenDir),
    AssociativityDir(AssociativityDir),
    AssertDir(AssertDir),
    ConstantDeclareDir(ConstantDeclareDir),
    DeclareDir(DeclareDir),
    DefineDir(DefineDir),
    ModuleDir(ModuleDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SortDecl {
    IdentSort(IdentSort),
    CompoundSortDecl(CompoundSortDecl),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum StructureConstructor {
    ConstantConstructor(ConstantConstructor),
    CompoundConstructor(CompoundConstructor),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ModuleDir {
    InfixModuleDir(InfixModuleDir),
    PrefixModuleDir(PrefixModuleDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DefineDir {
    InfixDefineDir(InfixDefineDir),
    PrefixDefineDir(PrefixDefineDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssertDir {
    InfixAssertDir(InfixAssertDir),
    PrefixAssertDir(PrefixAssertDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DeclareDir {
    PrefixDeclareDir(PrefixDeclareDir),
    InfixDeclareDir(InfixDeclareDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConstantDeclareDir {
    InfixConstantDeclare(InfixConstantDeclare),
    PrefixConstantDeclare(PrefixConstantDeclare),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PrefixDeclareSymbols {
    PrefixSingleSymbol(PrefixSingleSymbol),
    PrefixMultiSymbols(PrefixMultiSymbols),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    IdentExpr(IdentExpr),
    LiteralExpr(LiteralExpr),
    UnitExpr(UnitExpr),
    TermVarExpr(TermVarExpr),
    MetaIdent(MetaIdent),
    CheckExpr(CheckExpr),
    LambdaExpr(LambdaExpr),
    ApplicationExpr(ApplicationExpr),
    ListExpr(ListExpr),
    MethodExpr(MethodExpr),
    LetExpr(LetExpr),
    LetRecExpr(LetRecExpr),
    TryExpr(TryExpr),
    CellExpr(CellExpr),
    SetExpr(SetExpr),
    RefExpr(RefExpr),
    WhileExpr(WhileExpr),
    MakeVectorExpr(MakeVectorExpr),
    VectorSubExpr(VectorSubExpr),
    VectorSetExpr(VectorSetExpr),
    SeqExpr(SeqExpr),
    AndExpr(AndExpr),
    OrExpr(OrExpr),
    MapExpr(MapExpr),
    WildcardExpr(WildcardExpr),
    PrefixCheckExpr(PrefixCheckExpr),
    MatchExpr(MatchExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PrefixDefineDir {
    PrefixDefine(PrefixDefine),
    PrefixDefineBlocks(PrefixDefineBlocks),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DefineName {
    Identifier(Identifier),
    DefineNamedPattern(DefineNamedPattern),
    DefineProc(DefineProc),
    ListPat(ListPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RuleDir {
    InfixRuleDir(InfixRuleDir),
    PrefixRuleDir(PrefixRuleDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Ded {
    MethodCallDed(MethodCallDed),
    BangMethodCallDed(BangMethodCallDed),
    AssumeDed(AssumeDed),
    NamedAssumeDed(NamedAssumeDed),
    ProofByContraDed(ProofByContraDed),
    GeneralizeOverDed(GeneralizeOverDed),
    PickAnyDed(PickAnyDed),
    WithWitnessDed(WithWitnessDed),
    PickWitnessDed(PickWitnessDed),
    PickWitnessesDed(PickWitnessesDed),
    InductDed(InductDed),
    CasesDed(CasesDed),
    ConcludeDed(ConcludeDed),
    InferBlockDed(InferBlockDed),
    SeqDed(SeqDed),
    CheckDed(CheckDed),
    LetDed(LetDed),
    LetRecDed(LetRecDed),
    MatchDed(MatchDed),
    PrefixAssumeDed(PrefixAssumeDed),
    TryDed(TryDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MatchExpr {
    InfixMatchExpr(InfixMatchExpr),
    PrefixMatchExpr(PrefixMatchExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CheckDed {
    InfixCheckDed(InfixCheckDed),
    PrefixCheckDed(PrefixCheckDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MatchDed {
    InfixMatchDed(InfixMatchDed),
    PrefixMatchDed(PrefixMatchDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LetDed {
    InfixLetDed(InfixLetDed),
    PrefixLetDed(PrefixLetDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LetRecDed {
    InfixLetRecDed(InfixLetRecDed),
    PrefixLetRecDed(PrefixLetRecDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TryDed {
    InfixTryDed(InfixTryDed),
    PrefixTryDed(PrefixTryDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PrefixAssumeDed {
    PrefixNamedAssumeDed(PrefixNamedAssumeDed),
    PrefixSingleAssumeDed(PrefixSingleAssumeDed),
    PrefixAssumeLetDed(PrefixAssumeLetDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InferOrExpr {
    Expr(Expr),
    Inference(Inference),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Inference {
    InferFrom(InferFrom),
    InferBy(InferBy),
    Ded(Ded),
}
impl AstNode for Fake {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FAKE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Identifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENTIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MetaIdent {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == META_IDENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Unit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TYPED_PARAM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OpAnnotatedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OP_ANNOTATED_PARAM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Wildcard {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WILDCARD
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixBinding {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_BINDING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VarSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAR_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOURCE_FILE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DirStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DIR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PhraseStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PHRASE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructureNameDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCTURE_NAME_DEF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ConstantConstructor {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONSTANT_CONSTRUCTOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundConstructor {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_CONSTRUCTOR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MaybeTaggedSortDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAYBE_TAGGED_SORT_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructureDef {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCTURE_DEF
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DatatypeStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DATATYPE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructureStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCTURE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DatatypesStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DATATYPES_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for StructuresStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == STRUCTURES_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DomainDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOMAIN_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DomainsDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOMAINS_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LoadDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LOAD_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssertClosedDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSERT_CLOSED_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExtendModuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXTEND_MODULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OpenDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OPEN_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssociativityDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSOCIATIVITY_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixModuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_MODULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixModuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_MODULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundSortDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_SORT_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixConstantDeclare {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_CONSTANT_DECLARE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixConstantDeclare {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_CONSTANT_DECLARE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DECLARE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixSortVarsDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_SORT_VARS_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDeclareAttrs {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DECLARE_ATTRS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixSingleSymbol {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_SINGLE_SYMBOL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixMultiSymbols {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_MULTI_SYMBOLS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DeclareAttr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DECLARE_ATTR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InputTransformDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INPUT_TRANSFORM_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixDeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_DECLARE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SortVarsDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SORT_VARS_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FuncSorts {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNC_SORTS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DeclareAttrs {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DECLARE_ATTRS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixDefineDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_DEFINE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDefine {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DEFINE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDefineBlocks {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DEFINE_BLOCKS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixDefineBlock {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_DEFINE_BLOCK
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineNamedPattern {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_NAMED_PATTERN
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineProc {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_PROC
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixAssertDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_ASSERT_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixAssertDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_ASSERT_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixRuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_RULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixRuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_RULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExpandInputDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPAND_INPUT_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineSortDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_SORT_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExprPhrase {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPR_PHRASE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DedPhrase {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DED_PHRASE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LiteralExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnitExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TermVarExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TERM_VAR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LambdaExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LAMBDA_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ApplicationExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == APPLICATION_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MethodExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == METHOD_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetRecExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_REC_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CellExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CELL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RefExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == REF_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WhileExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHILE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MakeVectorExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAKE_VECTOR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VectorSubExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VECTOR_SUB_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VectorSetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VECTOR_SET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SeqExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SEQ_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AndExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == AND_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OrExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MapExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAP_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WildcardExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WILDCARD_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixCheckExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_CHECK_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MetaIdentExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == META_IDENT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixLetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_LET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetPart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixLetRecExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_LET_REC_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetRecPart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_REC_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixMatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_MATCH_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixMatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_MATCH_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixTryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_TRY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MapBinding {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAP_BINDING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MethodCallDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == METHOD_CALL_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BangMethodCallDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BANG_METHOD_CALL_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ProofByContraDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PROOF_BY_CONTRA_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GeneralizeOverDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GENERALIZE_OVER_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PickAnyDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PICK_ANY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WithWitnessDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WITH_WITNESS_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PickWitnessDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PICK_WITNESS_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PickWitnessesDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PICK_WITNESSES_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InductDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDUCT_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CasesDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CASES_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ConcludeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CONCLUDE_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InferBlockDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFER_BLOCK_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SeqDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SEQ_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssumePart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSUME_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixNamedAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_NAMED_ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixSingleAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_SINGLE_ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixAssumeLetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_ASSUME_LET_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RestrictedMatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESTRICTED_MATCH_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckDedClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_DED_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixCheckDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_CHECK_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixCheckDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_CHECK_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckDedArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_DED_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixMatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_MATCH_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixMatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_MATCH_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchDedArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_DED_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchDedClause {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_DED_CLAUSE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixLetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_LET_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixLetRecDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_LET_REC_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixLetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_LET_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixLetRecDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_LET_REC_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InfixTryDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFIX_TRY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PrefixTryDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PREFIX_TRY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryDedArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_DED_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MaybeNamedInference {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAYBE_NAMED_INFERENCE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MaybeWildcardOpAnnotatedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAYBE_WILDCARD_OP_ANNOTATED_PARAM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InferFrom {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFER_FROM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InferBy {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INFER_BY
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ByDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VarPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAR_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MetaIdentPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == META_IDENT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LiteralPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnitPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ValOfPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAL_OF_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListOfPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_OF_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SplitPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SPLIT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WherePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHERE_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SomeThingPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOME_THING_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OrPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OR_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SomeThing {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOME_THING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<Identifier> for MaybeTypedParam {
    fn from(node: Identifier) -> MaybeTypedParam {
        MaybeTypedParam::Identifier(node)
    }
}
impl From<TypedParam> for MaybeTypedParam {
    fn from(node: TypedParam) -> MaybeTypedParam {
        MaybeTypedParam::TypedParam(node)
    }
}
impl From<OpAnnotatedParam> for MaybeTypedParam {
    fn from(node: OpAnnotatedParam) -> MaybeTypedParam {
        MaybeTypedParam::OpAnnotatedParam(node)
    }
}
impl AstNode for MaybeTypedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENTIFIER | TYPED_PARAM | OP_ANNOTATED_PARAM)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENTIFIER => MaybeTypedParam::Identifier(Identifier { syntax }),
            TYPED_PARAM => MaybeTypedParam::TypedParam(TypedParam { syntax }),
            OP_ANNOTATED_PARAM => {
                MaybeTypedParam::OpAnnotatedParam(OpAnnotatedParam { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MaybeTypedParam::Identifier(it) => &it.syntax,
            MaybeTypedParam::TypedParam(it) => &it.syntax,
            MaybeTypedParam::OpAnnotatedParam(it) => &it.syntax,
        }
    }
}
impl From<VarSort> for Sort {
    fn from(node: VarSort) -> Sort {
        Sort::VarSort(node)
    }
}
impl From<IdentSort> for Sort {
    fn from(node: IdentSort) -> Sort {
        Sort::IdentSort(node)
    }
}
impl From<CompoundSort> for Sort {
    fn from(node: CompoundSort) -> Sort {
        Sort::CompoundSort(node)
    }
}
impl AstNode for Sort {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, VAR_SORT | IDENT_SORT | COMPOUND_SORT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            VAR_SORT => Sort::VarSort(VarSort { syntax }),
            IDENT_SORT => Sort::IdentSort(IdentSort { syntax }),
            COMPOUND_SORT => Sort::CompoundSort(CompoundSort { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Sort::VarSort(it) => &it.syntax,
            Sort::IdentSort(it) => &it.syntax,
            Sort::CompoundSort(it) => &it.syntax,
        }
    }
}
impl From<Wildcard> for MaybeWildcardTypedParam {
    fn from(node: Wildcard) -> MaybeWildcardTypedParam {
        MaybeWildcardTypedParam::Wildcard(node)
    }
}
impl From<MaybeTypedParam> for MaybeWildcardTypedParam {
    fn from(node: MaybeTypedParam) -> MaybeWildcardTypedParam {
        MaybeWildcardTypedParam::MaybeTypedParam(node)
    }
}
impl AstNode for MaybeWildcardTypedParam {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, WILDCARD | IDENTIFIER | TYPED_PARAM | OP_ANNOTATED_PARAM)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            WILDCARD => MaybeWildcardTypedParam::Wildcard(Wildcard { syntax }),
            IDENTIFIER => {
                MaybeWildcardTypedParam::MaybeTypedParam(
                    MaybeTypedParam::Identifier(Identifier { syntax }),
                )
            }
            TYPED_PARAM => {
                MaybeWildcardTypedParam::MaybeTypedParam(
                    MaybeTypedParam::TypedParam(TypedParam { syntax }),
                )
            }
            OP_ANNOTATED_PARAM => {
                MaybeWildcardTypedParam::MaybeTypedParam(
                    MaybeTypedParam::OpAnnotatedParam(OpAnnotatedParam { syntax }),
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MaybeWildcardTypedParam::Wildcard(it) => &it.syntax,
            MaybeWildcardTypedParam::MaybeTypedParam(it) => it.syntax(),
        }
    }
}
impl From<IdentPat> for Pat {
    fn from(node: IdentPat) -> Pat {
        Pat::IdentPat(node)
    }
}
impl From<VarPat> for Pat {
    fn from(node: VarPat) -> Pat {
        Pat::VarPat(node)
    }
}
impl From<MetaIdentPat> for Pat {
    fn from(node: MetaIdentPat) -> Pat {
        Pat::MetaIdentPat(node)
    }
}
impl From<LiteralPat> for Pat {
    fn from(node: LiteralPat) -> Pat {
        Pat::LiteralPat(node)
    }
}
impl From<UnitPat> for Pat {
    fn from(node: UnitPat) -> Pat {
        Pat::UnitPat(node)
    }
}
impl From<NamedPat> for Pat {
    fn from(node: NamedPat) -> Pat {
        Pat::NamedPat(node)
    }
}
impl From<ValOfPat> for Pat {
    fn from(node: ValOfPat) -> Pat {
        Pat::ValOfPat(node)
    }
}
impl From<ListOfPat> for Pat {
    fn from(node: ListOfPat) -> Pat {
        Pat::ListOfPat(node)
    }
}
impl From<SplitPat> for Pat {
    fn from(node: SplitPat) -> Pat {
        Pat::SplitPat(node)
    }
}
impl From<ListPat> for Pat {
    fn from(node: ListPat) -> Pat {
        Pat::ListPat(node)
    }
}
impl From<CompoundPat> for Pat {
    fn from(node: CompoundPat) -> Pat {
        Pat::CompoundPat(node)
    }
}
impl From<WherePat> for Pat {
    fn from(node: WherePat) -> Pat {
        Pat::WherePat(node)
    }
}
impl From<SomeThingPat> for Pat {
    fn from(node: SomeThingPat) -> Pat {
        Pat::SomeThingPat(node)
    }
}
impl AstNode for Pat {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, IDENT_PAT | VAR_PAT | META_IDENT_PAT | LITERAL_PAT | UNIT_PAT |
            NAMED_PAT | VAL_OF_PAT | LIST_OF_PAT | SPLIT_PAT | LIST_PAT | COMPOUND_PAT |
            WHERE_PAT | SOME_THING_PAT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PAT => Pat::IdentPat(IdentPat { syntax }),
            VAR_PAT => Pat::VarPat(VarPat { syntax }),
            META_IDENT_PAT => Pat::MetaIdentPat(MetaIdentPat { syntax }),
            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),
            UNIT_PAT => Pat::UnitPat(UnitPat { syntax }),
            NAMED_PAT => Pat::NamedPat(NamedPat { syntax }),
            VAL_OF_PAT => Pat::ValOfPat(ValOfPat { syntax }),
            LIST_OF_PAT => Pat::ListOfPat(ListOfPat { syntax }),
            SPLIT_PAT => Pat::SplitPat(SplitPat { syntax }),
            LIST_PAT => Pat::ListPat(ListPat { syntax }),
            COMPOUND_PAT => Pat::CompoundPat(CompoundPat { syntax }),
            WHERE_PAT => Pat::WherePat(WherePat { syntax }),
            SOME_THING_PAT => Pat::SomeThingPat(SomeThingPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Pat::IdentPat(it) => &it.syntax,
            Pat::VarPat(it) => &it.syntax,
            Pat::MetaIdentPat(it) => &it.syntax,
            Pat::LiteralPat(it) => &it.syntax,
            Pat::UnitPat(it) => &it.syntax,
            Pat::NamedPat(it) => &it.syntax,
            Pat::ValOfPat(it) => &it.syntax,
            Pat::ListOfPat(it) => &it.syntax,
            Pat::SplitPat(it) => &it.syntax,
            Pat::ListPat(it) => &it.syntax,
            Pat::CompoundPat(it) => &it.syntax,
            Pat::WherePat(it) => &it.syntax,
            Pat::SomeThingPat(it) => &it.syntax,
        }
    }
}
impl From<ExprPhrase> for Phrase {
    fn from(node: ExprPhrase) -> Phrase {
        Phrase::ExprPhrase(node)
    }
}
impl From<DedPhrase> for Phrase {
    fn from(node: DedPhrase) -> Phrase {
        Phrase::DedPhrase(node)
    }
}
impl AstNode for Phrase {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, EXPR_PHRASE | DED_PHRASE)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            EXPR_PHRASE => Phrase::ExprPhrase(ExprPhrase { syntax }),
            DED_PHRASE => Phrase::DedPhrase(DedPhrase { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Phrase::ExprPhrase(it) => &it.syntax,
            Phrase::DedPhrase(it) => &it.syntax,
        }
    }
}
impl From<DirStmt> for Stmt {
    fn from(node: DirStmt) -> Stmt {
        Stmt::DirStmt(node)
    }
}
impl From<PhraseStmt> for Stmt {
    fn from(node: PhraseStmt) -> Stmt {
        Stmt::PhraseStmt(node)
    }
}
impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, DIR_STMT | PHRASE_STMT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DIR_STMT => Stmt::DirStmt(DirStmt { syntax }),
            PHRASE_STMT => Stmt::PhraseStmt(PhraseStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::DirStmt(it) => &it.syntax,
            Stmt::PhraseStmt(it) => &it.syntax,
        }
    }
}
impl From<DomainDir> for Dir {
    fn from(node: DomainDir) -> Dir {
        Dir::DomainDir(node)
    }
}
impl From<DomainsDir> for Dir {
    fn from(node: DomainsDir) -> Dir {
        Dir::DomainsDir(node)
    }
}
impl From<LoadDir> for Dir {
    fn from(node: LoadDir) -> Dir {
        Dir::LoadDir(node)
    }
}
impl From<AssertClosedDir> for Dir {
    fn from(node: AssertClosedDir) -> Dir {
        Dir::AssertClosedDir(node)
    }
}
impl From<ExtendModuleDir> for Dir {
    fn from(node: ExtendModuleDir) -> Dir {
        Dir::ExtendModuleDir(node)
    }
}
impl From<OpenDir> for Dir {
    fn from(node: OpenDir) -> Dir {
        Dir::OpenDir(node)
    }
}
impl From<AssociativityDir> for Dir {
    fn from(node: AssociativityDir) -> Dir {
        Dir::AssociativityDir(node)
    }
}
impl From<AssertDir> for Dir {
    fn from(node: AssertDir) -> Dir {
        Dir::AssertDir(node)
    }
}
impl From<ConstantDeclareDir> for Dir {
    fn from(node: ConstantDeclareDir) -> Dir {
        Dir::ConstantDeclareDir(node)
    }
}
impl From<DeclareDir> for Dir {
    fn from(node: DeclareDir) -> Dir {
        Dir::DeclareDir(node)
    }
}
impl From<DefineDir> for Dir {
    fn from(node: DefineDir) -> Dir {
        Dir::DefineDir(node)
    }
}
impl From<ModuleDir> for Dir {
    fn from(node: ModuleDir) -> Dir {
        Dir::ModuleDir(node)
    }
}
impl AstNode for Dir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, DOMAIN_DIR | DOMAINS_DIR | LOAD_DIR | ASSERT_CLOSED_DIR |
            EXTEND_MODULE_DIR | OPEN_DIR | ASSOCIATIVITY_DIR | INFIX_MODULE_DIR |
            PREFIX_MODULE_DIR | INFIX_DEFINE_DIR | INFIX_ASSERT_DIR | PREFIX_ASSERT_DIR |
            PREFIX_DECLARE_DIR | INFIX_DECLARE_DIR | INFIX_CONSTANT_DECLARE |
            PREFIX_CONSTANT_DECLARE
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DOMAIN_DIR => Dir::DomainDir(DomainDir { syntax }),
            DOMAINS_DIR => Dir::DomainsDir(DomainsDir { syntax }),
            LOAD_DIR => Dir::LoadDir(LoadDir { syntax }),
            ASSERT_CLOSED_DIR => Dir::AssertClosedDir(AssertClosedDir { syntax }),
            EXTEND_MODULE_DIR => Dir::ExtendModuleDir(ExtendModuleDir { syntax }),
            OPEN_DIR => Dir::OpenDir(OpenDir { syntax }),
            ASSOCIATIVITY_DIR => Dir::AssociativityDir(AssociativityDir { syntax }),
            INFIX_MODULE_DIR => {
                Dir::ModuleDir(ModuleDir::InfixModuleDir(InfixModuleDir { syntax }))
            }
            PREFIX_MODULE_DIR => {
                Dir::ModuleDir(ModuleDir::PrefixModuleDir(PrefixModuleDir { syntax }))
            }
            INFIX_DEFINE_DIR => {
                Dir::DefineDir(DefineDir::InfixDefineDir(InfixDefineDir { syntax }))
            }
            INFIX_ASSERT_DIR => {
                Dir::AssertDir(AssertDir::InfixAssertDir(InfixAssertDir { syntax }))
            }
            PREFIX_ASSERT_DIR => {
                Dir::AssertDir(AssertDir::PrefixAssertDir(PrefixAssertDir { syntax }))
            }
            PREFIX_DECLARE_DIR => {
                Dir::DeclareDir(
                    DeclareDir::PrefixDeclareDir(PrefixDeclareDir { syntax }),
                )
            }
            INFIX_DECLARE_DIR => {
                Dir::DeclareDir(DeclareDir::InfixDeclareDir(InfixDeclareDir { syntax }))
            }
            INFIX_CONSTANT_DECLARE => {
                Dir::ConstantDeclareDir(
                    ConstantDeclareDir::InfixConstantDeclare(InfixConstantDeclare {
                        syntax,
                    }),
                )
            }
            PREFIX_CONSTANT_DECLARE => {
                Dir::ConstantDeclareDir(
                    ConstantDeclareDir::PrefixConstantDeclare(PrefixConstantDeclare {
                        syntax,
                    }),
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Dir::DomainDir(it) => &it.syntax,
            Dir::DomainsDir(it) => &it.syntax,
            Dir::LoadDir(it) => &it.syntax,
            Dir::AssertClosedDir(it) => &it.syntax,
            Dir::ExtendModuleDir(it) => &it.syntax,
            Dir::OpenDir(it) => &it.syntax,
            Dir::AssociativityDir(it) => &it.syntax,
            Dir::AssertDir(it) => it.syntax(),
            Dir::ConstantDeclareDir(it) => it.syntax(),
            Dir::DeclareDir(it) => it.syntax(),
            Dir::DefineDir(it) => it.syntax(),
            Dir::ModuleDir(it) => it.syntax(),
        }
    }
}
impl From<IdentSort> for SortDecl {
    fn from(node: IdentSort) -> SortDecl {
        SortDecl::IdentSort(node)
    }
}
impl From<CompoundSortDecl> for SortDecl {
    fn from(node: CompoundSortDecl) -> SortDecl {
        SortDecl::CompoundSortDecl(node)
    }
}
impl AstNode for SortDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENT_SORT | COMPOUND_SORT_DECL)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_SORT => SortDecl::IdentSort(IdentSort { syntax }),
            COMPOUND_SORT_DECL => SortDecl::CompoundSortDecl(CompoundSortDecl { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            SortDecl::IdentSort(it) => &it.syntax,
            SortDecl::CompoundSortDecl(it) => &it.syntax,
        }
    }
}
impl From<ConstantConstructor> for StructureConstructor {
    fn from(node: ConstantConstructor) -> StructureConstructor {
        StructureConstructor::ConstantConstructor(node)
    }
}
impl From<CompoundConstructor> for StructureConstructor {
    fn from(node: CompoundConstructor) -> StructureConstructor {
        StructureConstructor::CompoundConstructor(node)
    }
}
impl AstNode for StructureConstructor {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, CONSTANT_CONSTRUCTOR | COMPOUND_CONSTRUCTOR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            CONSTANT_CONSTRUCTOR => {
                StructureConstructor::ConstantConstructor(ConstantConstructor { syntax })
            }
            COMPOUND_CONSTRUCTOR => {
                StructureConstructor::CompoundConstructor(CompoundConstructor { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            StructureConstructor::ConstantConstructor(it) => &it.syntax,
            StructureConstructor::CompoundConstructor(it) => &it.syntax,
        }
    }
}
impl From<InfixModuleDir> for ModuleDir {
    fn from(node: InfixModuleDir) -> ModuleDir {
        ModuleDir::InfixModuleDir(node)
    }
}
impl From<PrefixModuleDir> for ModuleDir {
    fn from(node: PrefixModuleDir) -> ModuleDir {
        ModuleDir::PrefixModuleDir(node)
    }
}
impl AstNode for ModuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_MODULE_DIR | PREFIX_MODULE_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_MODULE_DIR => ModuleDir::InfixModuleDir(InfixModuleDir { syntax }),
            PREFIX_MODULE_DIR => ModuleDir::PrefixModuleDir(PrefixModuleDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ModuleDir::InfixModuleDir(it) => &it.syntax,
            ModuleDir::PrefixModuleDir(it) => &it.syntax,
        }
    }
}
impl From<InfixDefineDir> for DefineDir {
    fn from(node: InfixDefineDir) -> DefineDir {
        DefineDir::InfixDefineDir(node)
    }
}
impl From<PrefixDefineDir> for DefineDir {
    fn from(node: PrefixDefineDir) -> DefineDir {
        DefineDir::PrefixDefineDir(node)
    }
}
impl AstNode for DefineDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_DEFINE_DIR | PREFIX_DEFINE | PREFIX_DEFINE_BLOCKS)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_DEFINE_DIR => DefineDir::InfixDefineDir(InfixDefineDir { syntax }),
            PREFIX_DEFINE => {
                DefineDir::PrefixDefineDir(
                    PrefixDefineDir::PrefixDefine(PrefixDefine { syntax }),
                )
            }
            PREFIX_DEFINE_BLOCKS => {
                DefineDir::PrefixDefineDir(
                    PrefixDefineDir::PrefixDefineBlocks(PrefixDefineBlocks { syntax }),
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DefineDir::InfixDefineDir(it) => &it.syntax,
            DefineDir::PrefixDefineDir(it) => it.syntax(),
        }
    }
}
impl From<InfixAssertDir> for AssertDir {
    fn from(node: InfixAssertDir) -> AssertDir {
        AssertDir::InfixAssertDir(node)
    }
}
impl From<PrefixAssertDir> for AssertDir {
    fn from(node: PrefixAssertDir) -> AssertDir {
        AssertDir::PrefixAssertDir(node)
    }
}
impl AstNode for AssertDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_ASSERT_DIR | PREFIX_ASSERT_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_ASSERT_DIR => AssertDir::InfixAssertDir(InfixAssertDir { syntax }),
            PREFIX_ASSERT_DIR => AssertDir::PrefixAssertDir(PrefixAssertDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AssertDir::InfixAssertDir(it) => &it.syntax,
            AssertDir::PrefixAssertDir(it) => &it.syntax,
        }
    }
}
impl From<PrefixDeclareDir> for DeclareDir {
    fn from(node: PrefixDeclareDir) -> DeclareDir {
        DeclareDir::PrefixDeclareDir(node)
    }
}
impl From<InfixDeclareDir> for DeclareDir {
    fn from(node: InfixDeclareDir) -> DeclareDir {
        DeclareDir::InfixDeclareDir(node)
    }
}
impl AstNode for DeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, PREFIX_DECLARE_DIR | INFIX_DECLARE_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_DECLARE_DIR => {
                DeclareDir::PrefixDeclareDir(PrefixDeclareDir { syntax })
            }
            INFIX_DECLARE_DIR => DeclareDir::InfixDeclareDir(InfixDeclareDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DeclareDir::PrefixDeclareDir(it) => &it.syntax,
            DeclareDir::InfixDeclareDir(it) => &it.syntax,
        }
    }
}
impl From<InfixConstantDeclare> for ConstantDeclareDir {
    fn from(node: InfixConstantDeclare) -> ConstantDeclareDir {
        ConstantDeclareDir::InfixConstantDeclare(node)
    }
}
impl From<PrefixConstantDeclare> for ConstantDeclareDir {
    fn from(node: PrefixConstantDeclare) -> ConstantDeclareDir {
        ConstantDeclareDir::PrefixConstantDeclare(node)
    }
}
impl AstNode for ConstantDeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_CONSTANT_DECLARE | PREFIX_CONSTANT_DECLARE)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_CONSTANT_DECLARE => {
                ConstantDeclareDir::InfixConstantDeclare(InfixConstantDeclare { syntax })
            }
            PREFIX_CONSTANT_DECLARE => {
                ConstantDeclareDir::PrefixConstantDeclare(PrefixConstantDeclare {
                    syntax,
                })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ConstantDeclareDir::InfixConstantDeclare(it) => &it.syntax,
            ConstantDeclareDir::PrefixConstantDeclare(it) => &it.syntax,
        }
    }
}
impl From<PrefixSingleSymbol> for PrefixDeclareSymbols {
    fn from(node: PrefixSingleSymbol) -> PrefixDeclareSymbols {
        PrefixDeclareSymbols::PrefixSingleSymbol(node)
    }
}
impl From<PrefixMultiSymbols> for PrefixDeclareSymbols {
    fn from(node: PrefixMultiSymbols) -> PrefixDeclareSymbols {
        PrefixDeclareSymbols::PrefixMultiSymbols(node)
    }
}
impl AstNode for PrefixDeclareSymbols {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, PREFIX_SINGLE_SYMBOL | PREFIX_MULTI_SYMBOLS)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_SINGLE_SYMBOL => {
                PrefixDeclareSymbols::PrefixSingleSymbol(PrefixSingleSymbol { syntax })
            }
            PREFIX_MULTI_SYMBOLS => {
                PrefixDeclareSymbols::PrefixMultiSymbols(PrefixMultiSymbols { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            PrefixDeclareSymbols::PrefixSingleSymbol(it) => &it.syntax,
            PrefixDeclareSymbols::PrefixMultiSymbols(it) => &it.syntax,
        }
    }
}
impl From<IdentExpr> for Expr {
    fn from(node: IdentExpr) -> Expr {
        Expr::IdentExpr(node)
    }
}
impl From<LiteralExpr> for Expr {
    fn from(node: LiteralExpr) -> Expr {
        Expr::LiteralExpr(node)
    }
}
impl From<UnitExpr> for Expr {
    fn from(node: UnitExpr) -> Expr {
        Expr::UnitExpr(node)
    }
}
impl From<TermVarExpr> for Expr {
    fn from(node: TermVarExpr) -> Expr {
        Expr::TermVarExpr(node)
    }
}
impl From<MetaIdent> for Expr {
    fn from(node: MetaIdent) -> Expr {
        Expr::MetaIdent(node)
    }
}
impl From<CheckExpr> for Expr {
    fn from(node: CheckExpr) -> Expr {
        Expr::CheckExpr(node)
    }
}
impl From<LambdaExpr> for Expr {
    fn from(node: LambdaExpr) -> Expr {
        Expr::LambdaExpr(node)
    }
}
impl From<ApplicationExpr> for Expr {
    fn from(node: ApplicationExpr) -> Expr {
        Expr::ApplicationExpr(node)
    }
}
impl From<ListExpr> for Expr {
    fn from(node: ListExpr) -> Expr {
        Expr::ListExpr(node)
    }
}
impl From<MethodExpr> for Expr {
    fn from(node: MethodExpr) -> Expr {
        Expr::MethodExpr(node)
    }
}
impl From<LetExpr> for Expr {
    fn from(node: LetExpr) -> Expr {
        Expr::LetExpr(node)
    }
}
impl From<LetRecExpr> for Expr {
    fn from(node: LetRecExpr) -> Expr {
        Expr::LetRecExpr(node)
    }
}
impl From<TryExpr> for Expr {
    fn from(node: TryExpr) -> Expr {
        Expr::TryExpr(node)
    }
}
impl From<CellExpr> for Expr {
    fn from(node: CellExpr) -> Expr {
        Expr::CellExpr(node)
    }
}
impl From<SetExpr> for Expr {
    fn from(node: SetExpr) -> Expr {
        Expr::SetExpr(node)
    }
}
impl From<RefExpr> for Expr {
    fn from(node: RefExpr) -> Expr {
        Expr::RefExpr(node)
    }
}
impl From<WhileExpr> for Expr {
    fn from(node: WhileExpr) -> Expr {
        Expr::WhileExpr(node)
    }
}
impl From<MakeVectorExpr> for Expr {
    fn from(node: MakeVectorExpr) -> Expr {
        Expr::MakeVectorExpr(node)
    }
}
impl From<VectorSubExpr> for Expr {
    fn from(node: VectorSubExpr) -> Expr {
        Expr::VectorSubExpr(node)
    }
}
impl From<VectorSetExpr> for Expr {
    fn from(node: VectorSetExpr) -> Expr {
        Expr::VectorSetExpr(node)
    }
}
impl From<SeqExpr> for Expr {
    fn from(node: SeqExpr) -> Expr {
        Expr::SeqExpr(node)
    }
}
impl From<AndExpr> for Expr {
    fn from(node: AndExpr) -> Expr {
        Expr::AndExpr(node)
    }
}
impl From<OrExpr> for Expr {
    fn from(node: OrExpr) -> Expr {
        Expr::OrExpr(node)
    }
}
impl From<MapExpr> for Expr {
    fn from(node: MapExpr) -> Expr {
        Expr::MapExpr(node)
    }
}
impl From<WildcardExpr> for Expr {
    fn from(node: WildcardExpr) -> Expr {
        Expr::WildcardExpr(node)
    }
}
impl From<PrefixCheckExpr> for Expr {
    fn from(node: PrefixCheckExpr) -> Expr {
        Expr::PrefixCheckExpr(node)
    }
}
impl From<MatchExpr> for Expr {
    fn from(node: MatchExpr) -> Expr {
        Expr::MatchExpr(node)
    }
}
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, IDENT_EXPR | LITERAL_EXPR | UNIT_EXPR | TERM_VAR_EXPR | META_IDENT |
            CHECK_EXPR | LAMBDA_EXPR | APPLICATION_EXPR | LIST_EXPR | METHOD_EXPR |
            LET_EXPR | LET_REC_EXPR | TRY_EXPR | CELL_EXPR | SET_EXPR | REF_EXPR |
            WHILE_EXPR | MAKE_VECTOR_EXPR | VECTOR_SUB_EXPR | VECTOR_SET_EXPR | SEQ_EXPR
            | AND_EXPR | OR_EXPR | MAP_EXPR | WILDCARD_EXPR | PREFIX_CHECK_EXPR |
            INFIX_MATCH_EXPR | PREFIX_MATCH_EXPR
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_EXPR => Expr::IdentExpr(IdentExpr { syntax }),
            LITERAL_EXPR => Expr::LiteralExpr(LiteralExpr { syntax }),
            UNIT_EXPR => Expr::UnitExpr(UnitExpr { syntax }),
            TERM_VAR_EXPR => Expr::TermVarExpr(TermVarExpr { syntax }),
            META_IDENT => Expr::MetaIdent(MetaIdent { syntax }),
            CHECK_EXPR => Expr::CheckExpr(CheckExpr { syntax }),
            LAMBDA_EXPR => Expr::LambdaExpr(LambdaExpr { syntax }),
            APPLICATION_EXPR => Expr::ApplicationExpr(ApplicationExpr { syntax }),
            LIST_EXPR => Expr::ListExpr(ListExpr { syntax }),
            METHOD_EXPR => Expr::MethodExpr(MethodExpr { syntax }),
            LET_EXPR => Expr::LetExpr(LetExpr { syntax }),
            LET_REC_EXPR => Expr::LetRecExpr(LetRecExpr { syntax }),
            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),
            CELL_EXPR => Expr::CellExpr(CellExpr { syntax }),
            SET_EXPR => Expr::SetExpr(SetExpr { syntax }),
            REF_EXPR => Expr::RefExpr(RefExpr { syntax }),
            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),
            MAKE_VECTOR_EXPR => Expr::MakeVectorExpr(MakeVectorExpr { syntax }),
            VECTOR_SUB_EXPR => Expr::VectorSubExpr(VectorSubExpr { syntax }),
            VECTOR_SET_EXPR => Expr::VectorSetExpr(VectorSetExpr { syntax }),
            SEQ_EXPR => Expr::SeqExpr(SeqExpr { syntax }),
            AND_EXPR => Expr::AndExpr(AndExpr { syntax }),
            OR_EXPR => Expr::OrExpr(OrExpr { syntax }),
            MAP_EXPR => Expr::MapExpr(MapExpr { syntax }),
            WILDCARD_EXPR => Expr::WildcardExpr(WildcardExpr { syntax }),
            PREFIX_CHECK_EXPR => Expr::PrefixCheckExpr(PrefixCheckExpr { syntax }),
            INFIX_MATCH_EXPR => {
                Expr::MatchExpr(MatchExpr::InfixMatchExpr(InfixMatchExpr { syntax }))
            }
            PREFIX_MATCH_EXPR => {
                Expr::MatchExpr(MatchExpr::PrefixMatchExpr(PrefixMatchExpr { syntax }))
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::IdentExpr(it) => &it.syntax,
            Expr::LiteralExpr(it) => &it.syntax,
            Expr::UnitExpr(it) => &it.syntax,
            Expr::TermVarExpr(it) => &it.syntax,
            Expr::MetaIdent(it) => &it.syntax,
            Expr::CheckExpr(it) => &it.syntax,
            Expr::LambdaExpr(it) => &it.syntax,
            Expr::ApplicationExpr(it) => &it.syntax,
            Expr::ListExpr(it) => &it.syntax,
            Expr::MethodExpr(it) => &it.syntax,
            Expr::LetExpr(it) => &it.syntax,
            Expr::LetRecExpr(it) => &it.syntax,
            Expr::TryExpr(it) => &it.syntax,
            Expr::CellExpr(it) => &it.syntax,
            Expr::SetExpr(it) => &it.syntax,
            Expr::RefExpr(it) => &it.syntax,
            Expr::WhileExpr(it) => &it.syntax,
            Expr::MakeVectorExpr(it) => &it.syntax,
            Expr::VectorSubExpr(it) => &it.syntax,
            Expr::VectorSetExpr(it) => &it.syntax,
            Expr::SeqExpr(it) => &it.syntax,
            Expr::AndExpr(it) => &it.syntax,
            Expr::OrExpr(it) => &it.syntax,
            Expr::MapExpr(it) => &it.syntax,
            Expr::WildcardExpr(it) => &it.syntax,
            Expr::PrefixCheckExpr(it) => &it.syntax,
            Expr::MatchExpr(it) => it.syntax(),
        }
    }
}
impl From<PrefixDefine> for PrefixDefineDir {
    fn from(node: PrefixDefine) -> PrefixDefineDir {
        PrefixDefineDir::PrefixDefine(node)
    }
}
impl From<PrefixDefineBlocks> for PrefixDefineDir {
    fn from(node: PrefixDefineBlocks) -> PrefixDefineDir {
        PrefixDefineDir::PrefixDefineBlocks(node)
    }
}
impl AstNode for PrefixDefineDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, PREFIX_DEFINE | PREFIX_DEFINE_BLOCKS)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_DEFINE => PrefixDefineDir::PrefixDefine(PrefixDefine { syntax }),
            PREFIX_DEFINE_BLOCKS => {
                PrefixDefineDir::PrefixDefineBlocks(PrefixDefineBlocks { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            PrefixDefineDir::PrefixDefine(it) => &it.syntax,
            PrefixDefineDir::PrefixDefineBlocks(it) => &it.syntax,
        }
    }
}
impl From<Identifier> for DefineName {
    fn from(node: Identifier) -> DefineName {
        DefineName::Identifier(node)
    }
}
impl From<DefineNamedPattern> for DefineName {
    fn from(node: DefineNamedPattern) -> DefineName {
        DefineName::DefineNamedPattern(node)
    }
}
impl From<DefineProc> for DefineName {
    fn from(node: DefineProc) -> DefineName {
        DefineName::DefineProc(node)
    }
}
impl From<ListPat> for DefineName {
    fn from(node: ListPat) -> DefineName {
        DefineName::ListPat(node)
    }
}
impl AstNode for DefineName {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENTIFIER | DEFINE_NAMED_PATTERN | DEFINE_PROC | LIST_PAT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENTIFIER => DefineName::Identifier(Identifier { syntax }),
            DEFINE_NAMED_PATTERN => {
                DefineName::DefineNamedPattern(DefineNamedPattern { syntax })
            }
            DEFINE_PROC => DefineName::DefineProc(DefineProc { syntax }),
            LIST_PAT => DefineName::ListPat(ListPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            DefineName::Identifier(it) => &it.syntax,
            DefineName::DefineNamedPattern(it) => &it.syntax,
            DefineName::DefineProc(it) => &it.syntax,
            DefineName::ListPat(it) => &it.syntax,
        }
    }
}
impl From<InfixRuleDir> for RuleDir {
    fn from(node: InfixRuleDir) -> RuleDir {
        RuleDir::InfixRuleDir(node)
    }
}
impl From<PrefixRuleDir> for RuleDir {
    fn from(node: PrefixRuleDir) -> RuleDir {
        RuleDir::PrefixRuleDir(node)
    }
}
impl AstNode for RuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_RULE_DIR | PREFIX_RULE_DIR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_RULE_DIR => RuleDir::InfixRuleDir(InfixRuleDir { syntax }),
            PREFIX_RULE_DIR => RuleDir::PrefixRuleDir(PrefixRuleDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            RuleDir::InfixRuleDir(it) => &it.syntax,
            RuleDir::PrefixRuleDir(it) => &it.syntax,
        }
    }
}
impl From<MethodCallDed> for Ded {
    fn from(node: MethodCallDed) -> Ded {
        Ded::MethodCallDed(node)
    }
}
impl From<BangMethodCallDed> for Ded {
    fn from(node: BangMethodCallDed) -> Ded {
        Ded::BangMethodCallDed(node)
    }
}
impl From<AssumeDed> for Ded {
    fn from(node: AssumeDed) -> Ded {
        Ded::AssumeDed(node)
    }
}
impl From<NamedAssumeDed> for Ded {
    fn from(node: NamedAssumeDed) -> Ded {
        Ded::NamedAssumeDed(node)
    }
}
impl From<ProofByContraDed> for Ded {
    fn from(node: ProofByContraDed) -> Ded {
        Ded::ProofByContraDed(node)
    }
}
impl From<GeneralizeOverDed> for Ded {
    fn from(node: GeneralizeOverDed) -> Ded {
        Ded::GeneralizeOverDed(node)
    }
}
impl From<PickAnyDed> for Ded {
    fn from(node: PickAnyDed) -> Ded {
        Ded::PickAnyDed(node)
    }
}
impl From<WithWitnessDed> for Ded {
    fn from(node: WithWitnessDed) -> Ded {
        Ded::WithWitnessDed(node)
    }
}
impl From<PickWitnessDed> for Ded {
    fn from(node: PickWitnessDed) -> Ded {
        Ded::PickWitnessDed(node)
    }
}
impl From<PickWitnessesDed> for Ded {
    fn from(node: PickWitnessesDed) -> Ded {
        Ded::PickWitnessesDed(node)
    }
}
impl From<InductDed> for Ded {
    fn from(node: InductDed) -> Ded {
        Ded::InductDed(node)
    }
}
impl From<CasesDed> for Ded {
    fn from(node: CasesDed) -> Ded {
        Ded::CasesDed(node)
    }
}
impl From<ConcludeDed> for Ded {
    fn from(node: ConcludeDed) -> Ded {
        Ded::ConcludeDed(node)
    }
}
impl From<InferBlockDed> for Ded {
    fn from(node: InferBlockDed) -> Ded {
        Ded::InferBlockDed(node)
    }
}
impl From<SeqDed> for Ded {
    fn from(node: SeqDed) -> Ded {
        Ded::SeqDed(node)
    }
}
impl From<CheckDed> for Ded {
    fn from(node: CheckDed) -> Ded {
        Ded::CheckDed(node)
    }
}
impl From<LetDed> for Ded {
    fn from(node: LetDed) -> Ded {
        Ded::LetDed(node)
    }
}
impl From<LetRecDed> for Ded {
    fn from(node: LetRecDed) -> Ded {
        Ded::LetRecDed(node)
    }
}
impl From<MatchDed> for Ded {
    fn from(node: MatchDed) -> Ded {
        Ded::MatchDed(node)
    }
}
impl From<PrefixAssumeDed> for Ded {
    fn from(node: PrefixAssumeDed) -> Ded {
        Ded::PrefixAssumeDed(node)
    }
}
impl From<TryDed> for Ded {
    fn from(node: TryDed) -> Ded {
        Ded::TryDed(node)
    }
}
impl AstNode for Ded {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, METHOD_CALL_DED | BANG_METHOD_CALL_DED | ASSUME_DED | NAMED_ASSUME_DED
            | PROOF_BY_CONTRA_DED | GENERALIZE_OVER_DED | PICK_ANY_DED | WITH_WITNESS_DED
            | PICK_WITNESS_DED | PICK_WITNESSES_DED | INDUCT_DED | CASES_DED |
            CONCLUDE_DED | INFER_BLOCK_DED | SEQ_DED | INFIX_CHECK_DED | PREFIX_CHECK_DED
            | INFIX_MATCH_DED | PREFIX_MATCH_DED | INFIX_LET_DED | PREFIX_LET_DED |
            INFIX_LET_REC_DED | PREFIX_LET_REC_DED | INFIX_TRY_DED | PREFIX_TRY_DED |
            PREFIX_NAMED_ASSUME_DED | PREFIX_SINGLE_ASSUME_DED | PREFIX_ASSUME_LET_DED
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            METHOD_CALL_DED => Ded::MethodCallDed(MethodCallDed { syntax }),
            BANG_METHOD_CALL_DED => Ded::BangMethodCallDed(BangMethodCallDed { syntax }),
            ASSUME_DED => Ded::AssumeDed(AssumeDed { syntax }),
            NAMED_ASSUME_DED => Ded::NamedAssumeDed(NamedAssumeDed { syntax }),
            PROOF_BY_CONTRA_DED => Ded::ProofByContraDed(ProofByContraDed { syntax }),
            GENERALIZE_OVER_DED => Ded::GeneralizeOverDed(GeneralizeOverDed { syntax }),
            PICK_ANY_DED => Ded::PickAnyDed(PickAnyDed { syntax }),
            WITH_WITNESS_DED => Ded::WithWitnessDed(WithWitnessDed { syntax }),
            PICK_WITNESS_DED => Ded::PickWitnessDed(PickWitnessDed { syntax }),
            PICK_WITNESSES_DED => Ded::PickWitnessesDed(PickWitnessesDed { syntax }),
            INDUCT_DED => Ded::InductDed(InductDed { syntax }),
            CASES_DED => Ded::CasesDed(CasesDed { syntax }),
            CONCLUDE_DED => Ded::ConcludeDed(ConcludeDed { syntax }),
            INFER_BLOCK_DED => Ded::InferBlockDed(InferBlockDed { syntax }),
            SEQ_DED => Ded::SeqDed(SeqDed { syntax }),
            INFIX_CHECK_DED => {
                Ded::CheckDed(CheckDed::InfixCheckDed(InfixCheckDed { syntax }))
            }
            PREFIX_CHECK_DED => {
                Ded::CheckDed(CheckDed::PrefixCheckDed(PrefixCheckDed { syntax }))
            }
            INFIX_MATCH_DED => {
                Ded::MatchDed(MatchDed::InfixMatchDed(InfixMatchDed { syntax }))
            }
            PREFIX_MATCH_DED => {
                Ded::MatchDed(MatchDed::PrefixMatchDed(PrefixMatchDed { syntax }))
            }
            INFIX_LET_DED => Ded::LetDed(LetDed::InfixLetDed(InfixLetDed { syntax })),
            PREFIX_LET_DED => Ded::LetDed(LetDed::PrefixLetDed(PrefixLetDed { syntax })),
            INFIX_LET_REC_DED => {
                Ded::LetRecDed(LetRecDed::InfixLetRecDed(InfixLetRecDed { syntax }))
            }
            PREFIX_LET_REC_DED => {
                Ded::LetRecDed(LetRecDed::PrefixLetRecDed(PrefixLetRecDed { syntax }))
            }
            INFIX_TRY_DED => Ded::TryDed(TryDed::InfixTryDed(InfixTryDed { syntax })),
            PREFIX_TRY_DED => Ded::TryDed(TryDed::PrefixTryDed(PrefixTryDed { syntax })),
            PREFIX_NAMED_ASSUME_DED => {
                Ded::PrefixAssumeDed(
                    PrefixAssumeDed::PrefixNamedAssumeDed(PrefixNamedAssumeDed {
                        syntax,
                    }),
                )
            }
            PREFIX_SINGLE_ASSUME_DED => {
                Ded::PrefixAssumeDed(
                    PrefixAssumeDed::PrefixSingleAssumeDed(PrefixSingleAssumeDed {
                        syntax,
                    }),
                )
            }
            PREFIX_ASSUME_LET_DED => {
                Ded::PrefixAssumeDed(
                    PrefixAssumeDed::PrefixAssumeLetDed(PrefixAssumeLetDed { syntax }),
                )
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Ded::MethodCallDed(it) => &it.syntax,
            Ded::BangMethodCallDed(it) => &it.syntax,
            Ded::AssumeDed(it) => &it.syntax,
            Ded::NamedAssumeDed(it) => &it.syntax,
            Ded::ProofByContraDed(it) => &it.syntax,
            Ded::GeneralizeOverDed(it) => &it.syntax,
            Ded::PickAnyDed(it) => &it.syntax,
            Ded::WithWitnessDed(it) => &it.syntax,
            Ded::PickWitnessDed(it) => &it.syntax,
            Ded::PickWitnessesDed(it) => &it.syntax,
            Ded::InductDed(it) => &it.syntax,
            Ded::CasesDed(it) => &it.syntax,
            Ded::ConcludeDed(it) => &it.syntax,
            Ded::InferBlockDed(it) => &it.syntax,
            Ded::SeqDed(it) => &it.syntax,
            Ded::CheckDed(it) => it.syntax(),
            Ded::LetDed(it) => it.syntax(),
            Ded::LetRecDed(it) => it.syntax(),
            Ded::MatchDed(it) => it.syntax(),
            Ded::PrefixAssumeDed(it) => it.syntax(),
            Ded::TryDed(it) => it.syntax(),
        }
    }
}
impl From<InfixMatchExpr> for MatchExpr {
    fn from(node: InfixMatchExpr) -> MatchExpr {
        MatchExpr::InfixMatchExpr(node)
    }
}
impl From<PrefixMatchExpr> for MatchExpr {
    fn from(node: PrefixMatchExpr) -> MatchExpr {
        MatchExpr::PrefixMatchExpr(node)
    }
}
impl AstNode for MatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_MATCH_EXPR | PREFIX_MATCH_EXPR)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_MATCH_EXPR => MatchExpr::InfixMatchExpr(InfixMatchExpr { syntax }),
            PREFIX_MATCH_EXPR => MatchExpr::PrefixMatchExpr(PrefixMatchExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MatchExpr::InfixMatchExpr(it) => &it.syntax,
            MatchExpr::PrefixMatchExpr(it) => &it.syntax,
        }
    }
}
impl From<InfixCheckDed> for CheckDed {
    fn from(node: InfixCheckDed) -> CheckDed {
        CheckDed::InfixCheckDed(node)
    }
}
impl From<PrefixCheckDed> for CheckDed {
    fn from(node: PrefixCheckDed) -> CheckDed {
        CheckDed::PrefixCheckDed(node)
    }
}
impl AstNode for CheckDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_CHECK_DED | PREFIX_CHECK_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_CHECK_DED => CheckDed::InfixCheckDed(InfixCheckDed { syntax }),
            PREFIX_CHECK_DED => CheckDed::PrefixCheckDed(PrefixCheckDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            CheckDed::InfixCheckDed(it) => &it.syntax,
            CheckDed::PrefixCheckDed(it) => &it.syntax,
        }
    }
}
impl From<InfixMatchDed> for MatchDed {
    fn from(node: InfixMatchDed) -> MatchDed {
        MatchDed::InfixMatchDed(node)
    }
}
impl From<PrefixMatchDed> for MatchDed {
    fn from(node: PrefixMatchDed) -> MatchDed {
        MatchDed::PrefixMatchDed(node)
    }
}
impl AstNode for MatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_MATCH_DED | PREFIX_MATCH_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_MATCH_DED => MatchDed::InfixMatchDed(InfixMatchDed { syntax }),
            PREFIX_MATCH_DED => MatchDed::PrefixMatchDed(PrefixMatchDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MatchDed::InfixMatchDed(it) => &it.syntax,
            MatchDed::PrefixMatchDed(it) => &it.syntax,
        }
    }
}
impl From<InfixLetDed> for LetDed {
    fn from(node: InfixLetDed) -> LetDed {
        LetDed::InfixLetDed(node)
    }
}
impl From<PrefixLetDed> for LetDed {
    fn from(node: PrefixLetDed) -> LetDed {
        LetDed::PrefixLetDed(node)
    }
}
impl AstNode for LetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_LET_DED | PREFIX_LET_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_LET_DED => LetDed::InfixLetDed(InfixLetDed { syntax }),
            PREFIX_LET_DED => LetDed::PrefixLetDed(PrefixLetDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            LetDed::InfixLetDed(it) => &it.syntax,
            LetDed::PrefixLetDed(it) => &it.syntax,
        }
    }
}
impl From<InfixLetRecDed> for LetRecDed {
    fn from(node: InfixLetRecDed) -> LetRecDed {
        LetRecDed::InfixLetRecDed(node)
    }
}
impl From<PrefixLetRecDed> for LetRecDed {
    fn from(node: PrefixLetRecDed) -> LetRecDed {
        LetRecDed::PrefixLetRecDed(node)
    }
}
impl AstNode for LetRecDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_LET_REC_DED | PREFIX_LET_REC_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_LET_REC_DED => LetRecDed::InfixLetRecDed(InfixLetRecDed { syntax }),
            PREFIX_LET_REC_DED => LetRecDed::PrefixLetRecDed(PrefixLetRecDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            LetRecDed::InfixLetRecDed(it) => &it.syntax,
            LetRecDed::PrefixLetRecDed(it) => &it.syntax,
        }
    }
}
impl From<InfixTryDed> for TryDed {
    fn from(node: InfixTryDed) -> TryDed {
        TryDed::InfixTryDed(node)
    }
}
impl From<PrefixTryDed> for TryDed {
    fn from(node: PrefixTryDed) -> TryDed {
        TryDed::PrefixTryDed(node)
    }
}
impl AstNode for TryDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, INFIX_TRY_DED | PREFIX_TRY_DED)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFIX_TRY_DED => TryDed::InfixTryDed(InfixTryDed { syntax }),
            PREFIX_TRY_DED => TryDed::PrefixTryDed(PrefixTryDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TryDed::InfixTryDed(it) => &it.syntax,
            TryDed::PrefixTryDed(it) => &it.syntax,
        }
    }
}
impl From<PrefixNamedAssumeDed> for PrefixAssumeDed {
    fn from(node: PrefixNamedAssumeDed) -> PrefixAssumeDed {
        PrefixAssumeDed::PrefixNamedAssumeDed(node)
    }
}
impl From<PrefixSingleAssumeDed> for PrefixAssumeDed {
    fn from(node: PrefixSingleAssumeDed) -> PrefixAssumeDed {
        PrefixAssumeDed::PrefixSingleAssumeDed(node)
    }
}
impl From<PrefixAssumeLetDed> for PrefixAssumeDed {
    fn from(node: PrefixAssumeLetDed) -> PrefixAssumeDed {
        PrefixAssumeDed::PrefixAssumeLetDed(node)
    }
}
impl AstNode for PrefixAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, PREFIX_NAMED_ASSUME_DED | PREFIX_SINGLE_ASSUME_DED |
            PREFIX_ASSUME_LET_DED
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_NAMED_ASSUME_DED => {
                PrefixAssumeDed::PrefixNamedAssumeDed(PrefixNamedAssumeDed { syntax })
            }
            PREFIX_SINGLE_ASSUME_DED => {
                PrefixAssumeDed::PrefixSingleAssumeDed(PrefixSingleAssumeDed { syntax })
            }
            PREFIX_ASSUME_LET_DED => {
                PrefixAssumeDed::PrefixAssumeLetDed(PrefixAssumeLetDed { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            PrefixAssumeDed::PrefixNamedAssumeDed(it) => &it.syntax,
            PrefixAssumeDed::PrefixSingleAssumeDed(it) => &it.syntax,
            PrefixAssumeDed::PrefixAssumeLetDed(it) => &it.syntax,
        }
    }
}
impl From<Expr> for InferOrExpr {
    fn from(node: Expr) -> InferOrExpr {
        InferOrExpr::Expr(node)
    }
}
impl From<Inference> for InferOrExpr {
    fn from(node: Inference) -> InferOrExpr {
        InferOrExpr::Inference(node)
    }
}
impl AstNode for InferOrExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, | INFER_FROM | INFER_BY | IDENT_EXPR | LITERAL_EXPR | UNIT_EXPR |
            TERM_VAR_EXPR | META_IDENT | CHECK_EXPR | LAMBDA_EXPR | APPLICATION_EXPR |
            LIST_EXPR | METHOD_EXPR | LET_EXPR | LET_REC_EXPR | TRY_EXPR | CELL_EXPR |
            SET_EXPR | REF_EXPR | WHILE_EXPR | MAKE_VECTOR_EXPR | VECTOR_SUB_EXPR |
            VECTOR_SET_EXPR | SEQ_EXPR | AND_EXPR | OR_EXPR | MAP_EXPR | WILDCARD_EXPR |
            PREFIX_CHECK_EXPR
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFER_FROM => {
                InferOrExpr::Inference(Inference::InferFrom(InferFrom { syntax }))
            }
            INFER_BY => InferOrExpr::Inference(Inference::InferBy(InferBy { syntax })),
            IDENT_EXPR => InferOrExpr::Expr(Expr::IdentExpr(IdentExpr { syntax })),
            LITERAL_EXPR => InferOrExpr::Expr(Expr::LiteralExpr(LiteralExpr { syntax })),
            UNIT_EXPR => InferOrExpr::Expr(Expr::UnitExpr(UnitExpr { syntax })),
            TERM_VAR_EXPR => InferOrExpr::Expr(Expr::TermVarExpr(TermVarExpr { syntax })),
            META_IDENT => InferOrExpr::Expr(Expr::MetaIdent(MetaIdent { syntax })),
            CHECK_EXPR => InferOrExpr::Expr(Expr::CheckExpr(CheckExpr { syntax })),
            LAMBDA_EXPR => InferOrExpr::Expr(Expr::LambdaExpr(LambdaExpr { syntax })),
            APPLICATION_EXPR => {
                InferOrExpr::Expr(Expr::ApplicationExpr(ApplicationExpr { syntax }))
            }
            LIST_EXPR => InferOrExpr::Expr(Expr::ListExpr(ListExpr { syntax })),
            METHOD_EXPR => InferOrExpr::Expr(Expr::MethodExpr(MethodExpr { syntax })),
            LET_EXPR => InferOrExpr::Expr(Expr::LetExpr(LetExpr { syntax })),
            LET_REC_EXPR => InferOrExpr::Expr(Expr::LetRecExpr(LetRecExpr { syntax })),
            TRY_EXPR => InferOrExpr::Expr(Expr::TryExpr(TryExpr { syntax })),
            CELL_EXPR => InferOrExpr::Expr(Expr::CellExpr(CellExpr { syntax })),
            SET_EXPR => InferOrExpr::Expr(Expr::SetExpr(SetExpr { syntax })),
            REF_EXPR => InferOrExpr::Expr(Expr::RefExpr(RefExpr { syntax })),
            WHILE_EXPR => InferOrExpr::Expr(Expr::WhileExpr(WhileExpr { syntax })),
            MAKE_VECTOR_EXPR => {
                InferOrExpr::Expr(Expr::MakeVectorExpr(MakeVectorExpr { syntax }))
            }
            VECTOR_SUB_EXPR => {
                InferOrExpr::Expr(Expr::VectorSubExpr(VectorSubExpr { syntax }))
            }
            VECTOR_SET_EXPR => {
                InferOrExpr::Expr(Expr::VectorSetExpr(VectorSetExpr { syntax }))
            }
            SEQ_EXPR => InferOrExpr::Expr(Expr::SeqExpr(SeqExpr { syntax })),
            AND_EXPR => InferOrExpr::Expr(Expr::AndExpr(AndExpr { syntax })),
            OR_EXPR => InferOrExpr::Expr(Expr::OrExpr(OrExpr { syntax })),
            MAP_EXPR => InferOrExpr::Expr(Expr::MapExpr(MapExpr { syntax })),
            WILDCARD_EXPR => {
                InferOrExpr::Expr(Expr::WildcardExpr(WildcardExpr { syntax }))
            }
            PREFIX_CHECK_EXPR => {
                InferOrExpr::Expr(Expr::PrefixCheckExpr(PrefixCheckExpr { syntax }))
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            InferOrExpr::Expr(it) => it.syntax(),
            InferOrExpr::Inference(it) => it.syntax(),
        }
    }
}
impl From<InferFrom> for Inference {
    fn from(node: InferFrom) -> Inference {
        Inference::InferFrom(node)
    }
}
impl From<InferBy> for Inference {
    fn from(node: InferBy) -> Inference {
        Inference::InferBy(node)
    }
}
impl From<Ded> for Inference {
    fn from(node: Ded) -> Inference {
        Inference::Ded(node)
    }
}
impl AstNode for Inference {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, INFER_FROM | INFER_BY | METHOD_CALL_DED | BANG_METHOD_CALL_DED |
            ASSUME_DED | NAMED_ASSUME_DED | PROOF_BY_CONTRA_DED | GENERALIZE_OVER_DED |
            PICK_ANY_DED | WITH_WITNESS_DED | PICK_WITNESS_DED | PICK_WITNESSES_DED |
            INDUCT_DED | CASES_DED | CONCLUDE_DED | INFER_BLOCK_DED | SEQ_DED
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            INFER_FROM => Inference::InferFrom(InferFrom { syntax }),
            INFER_BY => Inference::InferBy(InferBy { syntax }),
            METHOD_CALL_DED => {
                Inference::Ded(Ded::MethodCallDed(MethodCallDed { syntax }))
            }
            BANG_METHOD_CALL_DED => {
                Inference::Ded(Ded::BangMethodCallDed(BangMethodCallDed { syntax }))
            }
            ASSUME_DED => Inference::Ded(Ded::AssumeDed(AssumeDed { syntax })),
            NAMED_ASSUME_DED => {
                Inference::Ded(Ded::NamedAssumeDed(NamedAssumeDed { syntax }))
            }
            PROOF_BY_CONTRA_DED => {
                Inference::Ded(Ded::ProofByContraDed(ProofByContraDed { syntax }))
            }
            GENERALIZE_OVER_DED => {
                Inference::Ded(Ded::GeneralizeOverDed(GeneralizeOverDed { syntax }))
            }
            PICK_ANY_DED => Inference::Ded(Ded::PickAnyDed(PickAnyDed { syntax })),
            WITH_WITNESS_DED => {
                Inference::Ded(Ded::WithWitnessDed(WithWitnessDed { syntax }))
            }
            PICK_WITNESS_DED => {
                Inference::Ded(Ded::PickWitnessDed(PickWitnessDed { syntax }))
            }
            PICK_WITNESSES_DED => {
                Inference::Ded(Ded::PickWitnessesDed(PickWitnessesDed { syntax }))
            }
            INDUCT_DED => Inference::Ded(Ded::InductDed(InductDed { syntax })),
            CASES_DED => Inference::Ded(Ded::CasesDed(CasesDed { syntax })),
            CONCLUDE_DED => Inference::Ded(Ded::ConcludeDed(ConcludeDed { syntax })),
            INFER_BLOCK_DED => {
                Inference::Ded(Ded::InferBlockDed(InferBlockDed { syntax }))
            }
            SEQ_DED => Inference::Ded(Ded::SeqDed(SeqDed { syntax })),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Inference::InferFrom(it) => &it.syntax,
            Inference::InferBy(it) => &it.syntax,
            Inference::Ded(it) => it.syntax(),
        }
    }
}
impl std::fmt::Display for MaybeTypedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Sort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeWildcardTypedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Phrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Dir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructureConstructor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssertDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstantDeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDeclareSymbols {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDefineDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Ded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferOrExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Inference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Fake {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Identifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaIdent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Unit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OpAnnotatedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Wildcard {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DirStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PhraseStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructureNameDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConstantConstructor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundConstructor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeTaggedSortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructureDef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DatatypeStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructureStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DatatypesStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for StructuresStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DomainDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DomainsDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LoadDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssertClosedDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExtendModuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OpenDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssociativityDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixModuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixModuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundSortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixConstantDeclare {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixConstantDeclare {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixSortVarsDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDeclareAttrs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixSingleSymbol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixMultiSymbols {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclareAttr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InputTransformDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixDeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SortVarsDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FuncSorts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclareAttrs {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixDefineDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDefine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDefineBlocks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixDefineBlock {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineNamedPattern {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineProc {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixAssertDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixAssertDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixRuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixRuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExpandInputDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineSortDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprPhrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DedPhrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TermVarExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ApplicationExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CellExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RefExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MakeVectorExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VectorSubExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VectorSetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SeqExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AndExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OrExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MapExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WildcardExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixCheckExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaIdentExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixLetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixLetRecExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixMatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixMatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixTryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MapBinding {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodCallDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BangMethodCallDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ProofByContraDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GeneralizeOverDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PickAnyDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WithWitnessDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PickWitnessDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PickWitnessesDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InductDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CasesDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ConcludeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferBlockDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SeqDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssumePart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixNamedAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixSingleAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixAssumeLetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestrictedMatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckDedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixCheckDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixCheckDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckDedArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixMatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixMatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchDedArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchDedClause {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixLetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixLetRecDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixLetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixLetRecDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InfixTryDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixTryDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryDedArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeNamedInference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MaybeWildcardOpAnnotatedParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferFrom {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InferBy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ByDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaIdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ValOfPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListOfPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SplitPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WherePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SomeThingPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OrPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SomeThing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
