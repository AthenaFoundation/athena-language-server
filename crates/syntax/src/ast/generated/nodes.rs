//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(non_snake_case, dead_code, unused_imports)]
use crate::{
    SyntaxNode, SyntaxToken, SyntaxKind::{self, *},
    ast::{self, AstNode, AstChildren, support},
    T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Identifier {
    pub(crate) syntax: SyntaxNode,
}
impl Identifier {
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaIdent {
    pub(crate) syntax: SyntaxNode,
}
impl MetaIdent {
    pub fn single_quote_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['\''])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Unit {
    pub(crate) syntax: SyntaxNode,
}
impl Unit {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VarSort {
    pub(crate) syntax: SyntaxNode,
}
impl VarSort {
    pub fn single_quote_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['\''])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentSort {
    pub(crate) syntax: SyntaxNode,
}
impl IdentSort {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundSort {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundSort {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn sorts(&self) -> AstChildren<Sort> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DirStmt {
    pub(crate) syntax: SyntaxNode,
}
impl DirStmt {
    pub fn dir(&self) -> Option<Dir> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PhraseStmt {
    pub(crate) syntax: SyntaxNode,
}
impl PhraseStmt {
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleDir {
    pub(crate) syntax: SyntaxNode,
}
impl ModuleDir {
    pub fn module_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![module])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DomainDir {
    pub(crate) syntax: SyntaxNode,
}
impl DomainDir {
    pub fn domain_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![domain])
    }
    pub fn sort_decl(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DomainsDir {
    pub(crate) syntax: SyntaxNode,
}
impl DomainsDir {
    pub fn domains_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![domains])
    }
    pub fn sort_decls(&self) -> AstChildren<SortDecl> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeclareDir {
    pub(crate) syntax: SyntaxNode,
}
impl DeclareDir {
    pub fn declare_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![declare])
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort_vars_decl(&self) -> Option<SortVarsDecl> {
        support::child(&self.syntax)
    }
    pub fn func_sorts(&self) -> Option<FuncSorts> {
        support::child(&self.syntax)
    }
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    pub fn return_sort(&self) -> Option<SortDecl> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineDir {
    pub(crate) syntax: SyntaxNode,
}
impl DefineDir {
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineProcDir {
    pub(crate) syntax: SyntaxNode,
}
impl DefineProcDir {
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn args(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefineMultiDir {
    pub(crate) syntax: SyntaxNode,
}
impl DefineMultiDir {
    pub fn define_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![define])
    }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundSortDecl {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundSortDecl {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn sort_decls(&self) -> AstChildren<SortDecl> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SortVarsDecl {
    pub(crate) syntax: SyntaxNode,
}
impl SortVarsDecl {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ident_sorts(&self) -> AstChildren<IdentSort> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FuncSorts {
    pub(crate) syntax: SyntaxNode,
}
impl FuncSorts {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn sort_decls(&self) -> AstChildren<SortDecl> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprPhrase {
    pub(crate) syntax: SyntaxNode,
}
impl ExprPhrase {
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DedPhrase {
    pub(crate) syntax: SyntaxNode,
}
impl DedPhrase {
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentExpr {
    pub(crate) syntax: SyntaxNode,
}
impl IdentExpr {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TermVarExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TermVarExpr {
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![?])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CheckExpr {
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn check_arms(&self) -> AstChildren<CheckArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LambdaExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LambdaExpr {
    pub fn lambda_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![lambda])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ApplicationExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ApplicationExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ListExpr {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MethodExpr {
    pub fn method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![method])
    }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LetExpr {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_parts(&self) -> AstChildren<LetPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetRecExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LetRecExpr {
    pub fn letrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![letrec])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_rec_parts(&self) -> AstChildren<LetRecPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MatchExpr {
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<MatchArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TryExpr {
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn try_arms(&self) -> AstChildren<TryArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CellExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CellExpr {
    pub fn cell_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![cell])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl SetExpr {
    pub fn set_bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![setbang])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RefExpr {
    pub(crate) syntax: SyntaxNode,
}
impl RefExpr {
    pub fn ref_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ref])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileExpr {
    pub(crate) syntax: SyntaxNode,
}
impl WhileExpr {
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MakeVectorExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MakeVectorExpr {
    pub fn make_vector_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![make_vector])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VectorSubExpr {
    pub(crate) syntax: SyntaxNode,
}
impl VectorSubExpr {
    pub fn vector_sub_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![vector_sub])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VectorSetExpr {
    pub(crate) syntax: SyntaxNode,
}
impl VectorSetExpr {
    pub fn vector_set_bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![vector_setbang])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SeqExpr {
    pub(crate) syntax: SyntaxNode,
}
impl SeqExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn seq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![seq])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AndExpr {
    pub(crate) syntax: SyntaxNode,
}
impl AndExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn ampamp_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![&&])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OrExpr {
    pub(crate) syntax: SyntaxNode,
}
impl OrExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pipepipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![||])
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralExpr {
    pub fn literal(&self) -> Option<Literal> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitExpr {
    pub(crate) syntax: SyntaxNode,
}
impl UnitExpr {
    pub fn unit(&self) -> Option<Unit> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckArm {
    pub(crate) syntax: SyntaxNode,
}
impl CheckArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetPart {
    pub(crate) syntax: SyntaxNode,
}
impl LetPart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetRecPart {
    pub(crate) syntax: SyntaxNode,
}
impl LetRecPart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchArm {
    pub(crate) syntax: SyntaxNode,
}
impl MatchArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryArm {
    pub(crate) syntax: SyntaxNode,
}
impl TryArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodCallDed {
    pub(crate) syntax: SyntaxNode,
}
impl MethodCallDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn apply_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![apply_method])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BangMethodCallDed {
    pub(crate) syntax: SyntaxNode,
}
impl BangMethodCallDed {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn bang_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![!])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrases(&self) -> AstChildren<Phrase> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl AssumeDed {
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedAssumeDed {
    pub(crate) syntax: SyntaxNode,
}
impl NamedAssumeDed {
    pub fn assume_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![assume])
    }
    pub fn assume_parts(&self) -> AstChildren<AssumePart> {
        support::children(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ProofByContraDed {
    pub(crate) syntax: SyntaxNode,
}
impl ProofByContraDed {
    pub fn suppose_absurd_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![suppose_absurd])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UniversalGeneralDed {
    pub(crate) syntax: SyntaxNode,
}
impl UniversalGeneralDed {
    pub fn generalize_over_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![generalize_over])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn pick_any_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick_any])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExistentialInstantDed {
    pub(crate) syntax: SyntaxNode,
}
impl ExistentialInstantDed {
    pub fn with_witness_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![with_witness])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn pick_witness_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick_witness])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    pub fn pick_witnesses_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![pick_witnesses])
    }
    pub fn identifiers(&self) -> AstChildren<Identifier> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InductDed {
    pub(crate) syntax: SyntaxNode,
}
impl InductDed {
    pub fn by_induction_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![by_induction])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn restricted_match_deds(&self) -> AstChildren<RestrictedMatchDed> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CasesDed {
    pub(crate) syntax: SyntaxNode,
}
impl CasesDed {
    pub fn datatype_cases_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![datatype_cases])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn restricted_match_deds(&self) -> AstChildren<RestrictedMatchDed> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckDed {
    pub(crate) syntax: SyntaxNode,
}
impl CheckDed {
    pub fn check_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![check])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<CheckDedArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchDed {
    pub(crate) syntax: SyntaxNode,
}
impl MatchDed {
    pub fn match_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![match])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn arms(&self) -> AstChildren<MatchDedArm> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetDed {
    pub(crate) syntax: SyntaxNode,
}
impl LetDed {
    pub fn let_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![let])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_parts(&self) -> AstChildren<LetPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetRecDed {
    pub(crate) syntax: SyntaxNode,
}
impl LetRecDed {
    pub fn letrec_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![letrec])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn let_rec_parts(&self) -> AstChildren<LetRecPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryDed {
    pub(crate) syntax: SyntaxNode,
}
impl TryDed {
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['{'])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
    pub fn try_ded_parts(&self) -> AstChildren<TryDedPart> {
        support::children(&self.syntax)
    }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['}'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssumePart {
    pub(crate) syntax: SyntaxNode,
}
impl AssumePart {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![;])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:=])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestrictedApplyPat {
    pub(crate) syntax: SyntaxNode,
}
impl RestrictedApplyPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn restricted_pat(&self) -> Option<RestrictedPat> {
        support::child(&self.syntax)
    }
    pub fn restricted_pats(&self) -> AstChildren<RestrictedPat> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestrictedNamedPat {
    pub(crate) syntax: SyntaxNode,
}
impl RestrictedNamedPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    pub fn restricted_pat(&self) -> Option<RestrictedPat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl IdentPat {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnnotatedIdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl AnnotatedIdentPat {
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestrictedMatchDed {
    pub(crate) syntax: SyntaxNode,
}
impl RestrictedMatchDed {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn restricted_pat(&self) -> Option<RestrictedPat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CheckDedArm {
    pub(crate) syntax: SyntaxNode,
}
impl CheckDedArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn phrase(&self) -> Option<Phrase> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MatchDedArm {
    pub(crate) syntax: SyntaxNode,
}
impl MatchDedArm {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn fat_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=>])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryDedPart {
    pub(crate) syntax: SyntaxNode,
}
impl TryDedPart {
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    pub fn ded(&self) -> Option<Ded> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VarPat {
    pub(crate) syntax: SyntaxNode,
}
impl VarPat {
    pub fn question_mark_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![?])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    pub fn sort(&self) -> Option<Sort> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaIdentPat {
    pub(crate) syntax: SyntaxNode,
}
impl MetaIdentPat {
    pub fn meta_ident(&self) -> Option<MetaIdent> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralPat {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralPat {
    pub fn literal(&self) -> Option<Literal> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnitPat {
    pub(crate) syntax: SyntaxNode,
}
impl UnitPat {
    pub fn unit(&self) -> Option<Unit> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WildcardPat {
    pub(crate) syntax: SyntaxNode,
}
impl WildcardPat {
    pub fn underscore_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![_])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedPat {
    pub(crate) syntax: SyntaxNode,
}
impl NamedPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn bind_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![bind])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ValOfPat {
    pub(crate) syntax: SyntaxNode,
}
impl ValOfPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn val_of_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![val_of])
    }
    pub fn identifier(&self) -> Option<Identifier> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListOfPat {
    pub(crate) syntax: SyntaxNode,
}
impl ListOfPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn list_of_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![list_of])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SplitPat {
    pub(crate) syntax: SyntaxNode,
}
impl SplitPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn split_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![split])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListPat {
    pub(crate) syntax: SyntaxNode,
}
impl ListPat {
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['['])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![']'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CompoundPat {
    pub(crate) syntax: SyntaxNode,
}
impl CompoundPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pats(&self) -> AstChildren<Pat> {
        support::children(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WherePat {
    pub(crate) syntax: SyntaxNode,
}
impl WherePat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn pat(&self) -> Option<Pat> {
        support::child(&self.syntax)
    }
    pub fn where_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![where])
    }
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SomeThingPat {
    pub(crate) syntax: SyntaxNode,
}
impl SomeThingPat {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!['('])
    }
    pub fn some_thing(&self) -> Option<SomeThing> {
        support::child(&self.syntax)
    }
    pub fn simple_pat(&self) -> Option<SimplePat> {
        support::child(&self.syntax)
    }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![')'])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SomeThing {
    pub(crate) syntax: SyntaxNode,
}
impl SomeThing {
    pub fn some_var_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_var])
    }
    pub fn some_sent_con_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_sent_con])
    }
    pub fn some_quant_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_quant])
    }
    pub fn some_term_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_term])
    }
    pub fn some_atom_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_atom])
    }
    pub fn some_sentence_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_sentence])
    }
    pub fn some_list_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_list])
    }
    pub fn some_cell_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_cell])
    }
    pub fn some_vector_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_vector])
    }
    pub fn some_proc_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_proc])
    }
    pub fn some_method_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_method])
    }
    pub fn some_symbol_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_symbol])
    }
    pub fn some_table_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_table])
    }
    pub fn some_map_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_map])
    }
    pub fn some_sub_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_sub])
    }
    pub fn some_char_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![some_char])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Sort {
    VarSort(VarSort),
    IdentSort(IdentSort),
    CompoundSort(CompoundSort),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    DirStmt(DirStmt),
    PhraseStmt(PhraseStmt),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Phrase {
    ExprPhrase(ExprPhrase),
    DedPhrase(DedPhrase),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Dir {
    ModuleDir(ModuleDir),
    DomainDir(DomainDir),
    DomainsDir(DomainsDir),
    DeclareDir(DeclareDir),
    DefineDir(DefineDir),
    DefineProcDir(DefineProcDir),
    DefineMultiDir(DefineMultiDir),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SortDecl {
    IdentSort(IdentSort),
    CompoundSortDecl(CompoundSortDecl),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pat {
    IdentPat(IdentPat),
    AnnotatedIdentPat(AnnotatedIdentPat),
    VarPat(VarPat),
    MetaIdentPat(MetaIdentPat),
    LiteralPat(LiteralPat),
    UnitPat(UnitPat),
    WildcardPat(WildcardPat),
    NamedPat(NamedPat),
    ValOfPat(ValOfPat),
    ListOfPat(ListOfPat),
    SplitPat(SplitPat),
    ListPat(ListPat),
    CompoundPat(CompoundPat),
    WherePat(WherePat),
    SomeThingPat(SomeThingPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    IdentExpr(IdentExpr),
    Literal(Literal),
    Unit(Unit),
    TermVarExpr(TermVarExpr),
    MetaIdent(MetaIdent),
    CheckExpr(CheckExpr),
    LambdaExpr(LambdaExpr),
    ApplicationExpr(ApplicationExpr),
    ListExpr(ListExpr),
    MethodExpr(MethodExpr),
    LetExpr(LetExpr),
    LetRecExpr(LetRecExpr),
    MatchExpr(MatchExpr),
    TryExpr(TryExpr),
    CellExpr(CellExpr),
    SetExpr(SetExpr),
    RefExpr(RefExpr),
    WhileExpr(WhileExpr),
    MakeVectorExpr(MakeVectorExpr),
    VectorSubExpr(VectorSubExpr),
    VectorSetExpr(VectorSetExpr),
    SeqExpr(SeqExpr),
    AndExpr(AndExpr),
    OrExpr(OrExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Ded {
    MethodCallDed(MethodCallDed),
    BangMethodCallDed(BangMethodCallDed),
    AssumeDed(AssumeDed),
    NamedAssumeDed(NamedAssumeDed),
    ProofByContraDed(ProofByContraDed),
    UniversalGeneralDed(UniversalGeneralDed),
    ExistentialInstantDed(ExistentialInstantDed),
    InductDed(InductDed),
    CasesDed(CasesDed),
    CheckDed(CheckDed),
    MatchDed(MatchDed),
    LetDed(LetDed),
    LetRecDed(LetRecDed),
    TryDed(TryDed),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RestrictedPat {
    IdentPat(IdentPat),
    AnnotatedIdentPat(AnnotatedIdentPat),
    RestrictedApplyPat(RestrictedApplyPat),
    RestrictedNamedPat(RestrictedNamedPat),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SimplePat {
    IdentPat(IdentPat),
    WildcardPat(WildcardPat),
}
impl AstNode for Identifier {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENTIFIER
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MetaIdent {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == META_IDENT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Unit {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VarSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAR_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundSort {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_SORT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DirStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DIR_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PhraseStmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PHRASE_STMT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ModuleDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MODULE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DomainDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOMAIN_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DomainsDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DOMAINS_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DeclareDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DECLARE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineProcDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_PROC_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DefineMultiDir {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DEFINE_MULTI_DIR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundSortDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_SORT_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SortVarsDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SORT_VARS_DECL
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FuncSorts {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FUNC_SORTS
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExprPhrase {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXPR_PHRASE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DedPhrase {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DED_PHRASE
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TermVarExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TERM_VAR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LambdaExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LAMBDA_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ApplicationExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == APPLICATION_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MethodExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == METHOD_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetRecExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_REC_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CellExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CELL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RefExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == REF_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WhileExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHILE_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MakeVectorExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MAKE_VECTOR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VectorSubExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VECTOR_SUB_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VectorSetExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VECTOR_SET_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SeqExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SEQ_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AndExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == AND_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for OrExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == OR_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LiteralExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnitExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT_EXPR
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetPart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetRecPart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_REC_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MethodCallDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == METHOD_CALL_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BangMethodCallDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BANG_METHOD_CALL_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedAssumeDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_ASSUME_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ProofByContraDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PROOF_BY_CONTRA_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UniversalGeneralDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIVERSAL_GENERAL_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ExistentialInstantDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == EXISTENTIAL_INSTANT_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for InductDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == INDUCT_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CasesDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CASES_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LetRecDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LET_REC_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssumePart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ASSUME_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RestrictedApplyPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESTRICTED_APPLY_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RestrictedNamedPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESTRICTED_NAMED_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IdentPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IDENT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AnnotatedIdentPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ANNOTATED_IDENT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RestrictedMatchDed {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RESTRICTED_MATCH_DED
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CheckDedArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CHECK_DED_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MatchDedArm {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MATCH_DED_ARM
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryDedPart {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TRY_DED_PART
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for VarPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAR_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MetaIdentPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == META_IDENT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LiteralPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LITERAL_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnitPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UNIT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WildcardPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WILDCARD_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NamedPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NAMED_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ValOfPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == VAL_OF_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListOfPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_OF_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SplitPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SPLIT_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LIST_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CompoundPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == COMPOUND_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WherePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WHERE_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SomeThingPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOME_THING_PAT
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for SomeThing {
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == SOME_THING
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }
    }
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<VarSort> for Sort {
    fn from(node: VarSort) -> Sort {
        Sort::VarSort(node)
    }
}
impl From<IdentSort> for Sort {
    fn from(node: IdentSort) -> Sort {
        Sort::IdentSort(node)
    }
}
impl From<CompoundSort> for Sort {
    fn from(node: CompoundSort) -> Sort {
        Sort::CompoundSort(node)
    }
}
impl AstNode for Sort {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, VAR_SORT | IDENT_SORT | COMPOUND_SORT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            VAR_SORT => Sort::VarSort(VarSort { syntax }),
            IDENT_SORT => Sort::IdentSort(IdentSort { syntax }),
            COMPOUND_SORT => Sort::CompoundSort(CompoundSort { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Sort::VarSort(it) => &it.syntax,
            Sort::IdentSort(it) => &it.syntax,
            Sort::CompoundSort(it) => &it.syntax,
        }
    }
}
impl From<DirStmt> for Stmt {
    fn from(node: DirStmt) -> Stmt {
        Stmt::DirStmt(node)
    }
}
impl From<PhraseStmt> for Stmt {
    fn from(node: PhraseStmt) -> Stmt {
        Stmt::PhraseStmt(node)
    }
}
impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, DIR_STMT | PHRASE_STMT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DIR_STMT => Stmt::DirStmt(DirStmt { syntax }),
            PHRASE_STMT => Stmt::PhraseStmt(PhraseStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::DirStmt(it) => &it.syntax,
            Stmt::PhraseStmt(it) => &it.syntax,
        }
    }
}
impl From<ExprPhrase> for Phrase {
    fn from(node: ExprPhrase) -> Phrase {
        Phrase::ExprPhrase(node)
    }
}
impl From<DedPhrase> for Phrase {
    fn from(node: DedPhrase) -> Phrase {
        Phrase::DedPhrase(node)
    }
}
impl AstNode for Phrase {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, EXPR_PHRASE | DED_PHRASE)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            EXPR_PHRASE => Phrase::ExprPhrase(ExprPhrase { syntax }),
            DED_PHRASE => Phrase::DedPhrase(DedPhrase { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Phrase::ExprPhrase(it) => &it.syntax,
            Phrase::DedPhrase(it) => &it.syntax,
        }
    }
}
impl From<ModuleDir> for Dir {
    fn from(node: ModuleDir) -> Dir {
        Dir::ModuleDir(node)
    }
}
impl From<DomainDir> for Dir {
    fn from(node: DomainDir) -> Dir {
        Dir::DomainDir(node)
    }
}
impl From<DomainsDir> for Dir {
    fn from(node: DomainsDir) -> Dir {
        Dir::DomainsDir(node)
    }
}
impl From<DeclareDir> for Dir {
    fn from(node: DeclareDir) -> Dir {
        Dir::DeclareDir(node)
    }
}
impl From<DefineDir> for Dir {
    fn from(node: DefineDir) -> Dir {
        Dir::DefineDir(node)
    }
}
impl From<DefineProcDir> for Dir {
    fn from(node: DefineProcDir) -> Dir {
        Dir::DefineProcDir(node)
    }
}
impl From<DefineMultiDir> for Dir {
    fn from(node: DefineMultiDir) -> Dir {
        Dir::DefineMultiDir(node)
    }
}
impl AstNode for Dir {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, MODULE_DIR | DOMAIN_DIR | DOMAINS_DIR | DECLARE_DIR | DEFINE_DIR |
            DEFINE_PROC_DIR | DEFINE_MULTI_DIR
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            MODULE_DIR => Dir::ModuleDir(ModuleDir { syntax }),
            DOMAIN_DIR => Dir::DomainDir(DomainDir { syntax }),
            DOMAINS_DIR => Dir::DomainsDir(DomainsDir { syntax }),
            DECLARE_DIR => Dir::DeclareDir(DeclareDir { syntax }),
            DEFINE_DIR => Dir::DefineDir(DefineDir { syntax }),
            DEFINE_PROC_DIR => Dir::DefineProcDir(DefineProcDir { syntax }),
            DEFINE_MULTI_DIR => Dir::DefineMultiDir(DefineMultiDir { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Dir::ModuleDir(it) => &it.syntax,
            Dir::DomainDir(it) => &it.syntax,
            Dir::DomainsDir(it) => &it.syntax,
            Dir::DeclareDir(it) => &it.syntax,
            Dir::DefineDir(it) => &it.syntax,
            Dir::DefineProcDir(it) => &it.syntax,
            Dir::DefineMultiDir(it) => &it.syntax,
        }
    }
}
impl From<IdentSort> for SortDecl {
    fn from(node: IdentSort) -> SortDecl {
        SortDecl::IdentSort(node)
    }
}
impl From<CompoundSortDecl> for SortDecl {
    fn from(node: CompoundSortDecl) -> SortDecl {
        SortDecl::CompoundSortDecl(node)
    }
}
impl AstNode for SortDecl {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENT_SORT | COMPOUND_SORT_DECL)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_SORT => SortDecl::IdentSort(IdentSort { syntax }),
            COMPOUND_SORT_DECL => SortDecl::CompoundSortDecl(CompoundSortDecl { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            SortDecl::IdentSort(it) => &it.syntax,
            SortDecl::CompoundSortDecl(it) => &it.syntax,
        }
    }
}
impl From<IdentPat> for Pat {
    fn from(node: IdentPat) -> Pat {
        Pat::IdentPat(node)
    }
}
impl From<AnnotatedIdentPat> for Pat {
    fn from(node: AnnotatedIdentPat) -> Pat {
        Pat::AnnotatedIdentPat(node)
    }
}
impl From<VarPat> for Pat {
    fn from(node: VarPat) -> Pat {
        Pat::VarPat(node)
    }
}
impl From<MetaIdentPat> for Pat {
    fn from(node: MetaIdentPat) -> Pat {
        Pat::MetaIdentPat(node)
    }
}
impl From<LiteralPat> for Pat {
    fn from(node: LiteralPat) -> Pat {
        Pat::LiteralPat(node)
    }
}
impl From<UnitPat> for Pat {
    fn from(node: UnitPat) -> Pat {
        Pat::UnitPat(node)
    }
}
impl From<WildcardPat> for Pat {
    fn from(node: WildcardPat) -> Pat {
        Pat::WildcardPat(node)
    }
}
impl From<NamedPat> for Pat {
    fn from(node: NamedPat) -> Pat {
        Pat::NamedPat(node)
    }
}
impl From<ValOfPat> for Pat {
    fn from(node: ValOfPat) -> Pat {
        Pat::ValOfPat(node)
    }
}
impl From<ListOfPat> for Pat {
    fn from(node: ListOfPat) -> Pat {
        Pat::ListOfPat(node)
    }
}
impl From<SplitPat> for Pat {
    fn from(node: SplitPat) -> Pat {
        Pat::SplitPat(node)
    }
}
impl From<ListPat> for Pat {
    fn from(node: ListPat) -> Pat {
        Pat::ListPat(node)
    }
}
impl From<CompoundPat> for Pat {
    fn from(node: CompoundPat) -> Pat {
        Pat::CompoundPat(node)
    }
}
impl From<WherePat> for Pat {
    fn from(node: WherePat) -> Pat {
        Pat::WherePat(node)
    }
}
impl From<SomeThingPat> for Pat {
    fn from(node: SomeThingPat) -> Pat {
        Pat::SomeThingPat(node)
    }
}
impl AstNode for Pat {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, IDENT_PAT | ANNOTATED_IDENT_PAT | VAR_PAT | META_IDENT_PAT |
            LITERAL_PAT | UNIT_PAT | WILDCARD_PAT | NAMED_PAT | VAL_OF_PAT | LIST_OF_PAT
            | SPLIT_PAT | LIST_PAT | COMPOUND_PAT | WHERE_PAT | SOME_THING_PAT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PAT => Pat::IdentPat(IdentPat { syntax }),
            ANNOTATED_IDENT_PAT => Pat::AnnotatedIdentPat(AnnotatedIdentPat { syntax }),
            VAR_PAT => Pat::VarPat(VarPat { syntax }),
            META_IDENT_PAT => Pat::MetaIdentPat(MetaIdentPat { syntax }),
            LITERAL_PAT => Pat::LiteralPat(LiteralPat { syntax }),
            UNIT_PAT => Pat::UnitPat(UnitPat { syntax }),
            WILDCARD_PAT => Pat::WildcardPat(WildcardPat { syntax }),
            NAMED_PAT => Pat::NamedPat(NamedPat { syntax }),
            VAL_OF_PAT => Pat::ValOfPat(ValOfPat { syntax }),
            LIST_OF_PAT => Pat::ListOfPat(ListOfPat { syntax }),
            SPLIT_PAT => Pat::SplitPat(SplitPat { syntax }),
            LIST_PAT => Pat::ListPat(ListPat { syntax }),
            COMPOUND_PAT => Pat::CompoundPat(CompoundPat { syntax }),
            WHERE_PAT => Pat::WherePat(WherePat { syntax }),
            SOME_THING_PAT => Pat::SomeThingPat(SomeThingPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Pat::IdentPat(it) => &it.syntax,
            Pat::AnnotatedIdentPat(it) => &it.syntax,
            Pat::VarPat(it) => &it.syntax,
            Pat::MetaIdentPat(it) => &it.syntax,
            Pat::LiteralPat(it) => &it.syntax,
            Pat::UnitPat(it) => &it.syntax,
            Pat::WildcardPat(it) => &it.syntax,
            Pat::NamedPat(it) => &it.syntax,
            Pat::ValOfPat(it) => &it.syntax,
            Pat::ListOfPat(it) => &it.syntax,
            Pat::SplitPat(it) => &it.syntax,
            Pat::ListPat(it) => &it.syntax,
            Pat::CompoundPat(it) => &it.syntax,
            Pat::WherePat(it) => &it.syntax,
            Pat::SomeThingPat(it) => &it.syntax,
        }
    }
}
impl From<IdentExpr> for Expr {
    fn from(node: IdentExpr) -> Expr {
        Expr::IdentExpr(node)
    }
}
impl From<Literal> for Expr {
    fn from(node: Literal) -> Expr {
        Expr::Literal(node)
    }
}
impl From<Unit> for Expr {
    fn from(node: Unit) -> Expr {
        Expr::Unit(node)
    }
}
impl From<TermVarExpr> for Expr {
    fn from(node: TermVarExpr) -> Expr {
        Expr::TermVarExpr(node)
    }
}
impl From<MetaIdent> for Expr {
    fn from(node: MetaIdent) -> Expr {
        Expr::MetaIdent(node)
    }
}
impl From<CheckExpr> for Expr {
    fn from(node: CheckExpr) -> Expr {
        Expr::CheckExpr(node)
    }
}
impl From<LambdaExpr> for Expr {
    fn from(node: LambdaExpr) -> Expr {
        Expr::LambdaExpr(node)
    }
}
impl From<ApplicationExpr> for Expr {
    fn from(node: ApplicationExpr) -> Expr {
        Expr::ApplicationExpr(node)
    }
}
impl From<ListExpr> for Expr {
    fn from(node: ListExpr) -> Expr {
        Expr::ListExpr(node)
    }
}
impl From<MethodExpr> for Expr {
    fn from(node: MethodExpr) -> Expr {
        Expr::MethodExpr(node)
    }
}
impl From<LetExpr> for Expr {
    fn from(node: LetExpr) -> Expr {
        Expr::LetExpr(node)
    }
}
impl From<LetRecExpr> for Expr {
    fn from(node: LetRecExpr) -> Expr {
        Expr::LetRecExpr(node)
    }
}
impl From<MatchExpr> for Expr {
    fn from(node: MatchExpr) -> Expr {
        Expr::MatchExpr(node)
    }
}
impl From<TryExpr> for Expr {
    fn from(node: TryExpr) -> Expr {
        Expr::TryExpr(node)
    }
}
impl From<CellExpr> for Expr {
    fn from(node: CellExpr) -> Expr {
        Expr::CellExpr(node)
    }
}
impl From<SetExpr> for Expr {
    fn from(node: SetExpr) -> Expr {
        Expr::SetExpr(node)
    }
}
impl From<RefExpr> for Expr {
    fn from(node: RefExpr) -> Expr {
        Expr::RefExpr(node)
    }
}
impl From<WhileExpr> for Expr {
    fn from(node: WhileExpr) -> Expr {
        Expr::WhileExpr(node)
    }
}
impl From<MakeVectorExpr> for Expr {
    fn from(node: MakeVectorExpr) -> Expr {
        Expr::MakeVectorExpr(node)
    }
}
impl From<VectorSubExpr> for Expr {
    fn from(node: VectorSubExpr) -> Expr {
        Expr::VectorSubExpr(node)
    }
}
impl From<VectorSetExpr> for Expr {
    fn from(node: VectorSetExpr) -> Expr {
        Expr::VectorSetExpr(node)
    }
}
impl From<SeqExpr> for Expr {
    fn from(node: SeqExpr) -> Expr {
        Expr::SeqExpr(node)
    }
}
impl From<AndExpr> for Expr {
    fn from(node: AndExpr) -> Expr {
        Expr::AndExpr(node)
    }
}
impl From<OrExpr> for Expr {
    fn from(node: OrExpr) -> Expr {
        Expr::OrExpr(node)
    }
}
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, IDENT_EXPR | LITERAL | UNIT | TERM_VAR_EXPR | META_IDENT | CHECK_EXPR |
            LAMBDA_EXPR | APPLICATION_EXPR | LIST_EXPR | METHOD_EXPR | LET_EXPR |
            LET_REC_EXPR | MATCH_EXPR | TRY_EXPR | CELL_EXPR | SET_EXPR | REF_EXPR |
            WHILE_EXPR | MAKE_VECTOR_EXPR | VECTOR_SUB_EXPR | VECTOR_SET_EXPR | SEQ_EXPR
            | AND_EXPR | OR_EXPR
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_EXPR => Expr::IdentExpr(IdentExpr { syntax }),
            LITERAL => Expr::Literal(Literal { syntax }),
            UNIT => Expr::Unit(Unit { syntax }),
            TERM_VAR_EXPR => Expr::TermVarExpr(TermVarExpr { syntax }),
            META_IDENT => Expr::MetaIdent(MetaIdent { syntax }),
            CHECK_EXPR => Expr::CheckExpr(CheckExpr { syntax }),
            LAMBDA_EXPR => Expr::LambdaExpr(LambdaExpr { syntax }),
            APPLICATION_EXPR => Expr::ApplicationExpr(ApplicationExpr { syntax }),
            LIST_EXPR => Expr::ListExpr(ListExpr { syntax }),
            METHOD_EXPR => Expr::MethodExpr(MethodExpr { syntax }),
            LET_EXPR => Expr::LetExpr(LetExpr { syntax }),
            LET_REC_EXPR => Expr::LetRecExpr(LetRecExpr { syntax }),
            MATCH_EXPR => Expr::MatchExpr(MatchExpr { syntax }),
            TRY_EXPR => Expr::TryExpr(TryExpr { syntax }),
            CELL_EXPR => Expr::CellExpr(CellExpr { syntax }),
            SET_EXPR => Expr::SetExpr(SetExpr { syntax }),
            REF_EXPR => Expr::RefExpr(RefExpr { syntax }),
            WHILE_EXPR => Expr::WhileExpr(WhileExpr { syntax }),
            MAKE_VECTOR_EXPR => Expr::MakeVectorExpr(MakeVectorExpr { syntax }),
            VECTOR_SUB_EXPR => Expr::VectorSubExpr(VectorSubExpr { syntax }),
            VECTOR_SET_EXPR => Expr::VectorSetExpr(VectorSetExpr { syntax }),
            SEQ_EXPR => Expr::SeqExpr(SeqExpr { syntax }),
            AND_EXPR => Expr::AndExpr(AndExpr { syntax }),
            OR_EXPR => Expr::OrExpr(OrExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::IdentExpr(it) => &it.syntax,
            Expr::Literal(it) => &it.syntax,
            Expr::Unit(it) => &it.syntax,
            Expr::TermVarExpr(it) => &it.syntax,
            Expr::MetaIdent(it) => &it.syntax,
            Expr::CheckExpr(it) => &it.syntax,
            Expr::LambdaExpr(it) => &it.syntax,
            Expr::ApplicationExpr(it) => &it.syntax,
            Expr::ListExpr(it) => &it.syntax,
            Expr::MethodExpr(it) => &it.syntax,
            Expr::LetExpr(it) => &it.syntax,
            Expr::LetRecExpr(it) => &it.syntax,
            Expr::MatchExpr(it) => &it.syntax,
            Expr::TryExpr(it) => &it.syntax,
            Expr::CellExpr(it) => &it.syntax,
            Expr::SetExpr(it) => &it.syntax,
            Expr::RefExpr(it) => &it.syntax,
            Expr::WhileExpr(it) => &it.syntax,
            Expr::MakeVectorExpr(it) => &it.syntax,
            Expr::VectorSubExpr(it) => &it.syntax,
            Expr::VectorSetExpr(it) => &it.syntax,
            Expr::SeqExpr(it) => &it.syntax,
            Expr::AndExpr(it) => &it.syntax,
            Expr::OrExpr(it) => &it.syntax,
        }
    }
}
impl From<MethodCallDed> for Ded {
    fn from(node: MethodCallDed) -> Ded {
        Ded::MethodCallDed(node)
    }
}
impl From<BangMethodCallDed> for Ded {
    fn from(node: BangMethodCallDed) -> Ded {
        Ded::BangMethodCallDed(node)
    }
}
impl From<AssumeDed> for Ded {
    fn from(node: AssumeDed) -> Ded {
        Ded::AssumeDed(node)
    }
}
impl From<NamedAssumeDed> for Ded {
    fn from(node: NamedAssumeDed) -> Ded {
        Ded::NamedAssumeDed(node)
    }
}
impl From<ProofByContraDed> for Ded {
    fn from(node: ProofByContraDed) -> Ded {
        Ded::ProofByContraDed(node)
    }
}
impl From<UniversalGeneralDed> for Ded {
    fn from(node: UniversalGeneralDed) -> Ded {
        Ded::UniversalGeneralDed(node)
    }
}
impl From<ExistentialInstantDed> for Ded {
    fn from(node: ExistentialInstantDed) -> Ded {
        Ded::ExistentialInstantDed(node)
    }
}
impl From<InductDed> for Ded {
    fn from(node: InductDed) -> Ded {
        Ded::InductDed(node)
    }
}
impl From<CasesDed> for Ded {
    fn from(node: CasesDed) -> Ded {
        Ded::CasesDed(node)
    }
}
impl From<CheckDed> for Ded {
    fn from(node: CheckDed) -> Ded {
        Ded::CheckDed(node)
    }
}
impl From<MatchDed> for Ded {
    fn from(node: MatchDed) -> Ded {
        Ded::MatchDed(node)
    }
}
impl From<LetDed> for Ded {
    fn from(node: LetDed) -> Ded {
        Ded::LetDed(node)
    }
}
impl From<LetRecDed> for Ded {
    fn from(node: LetRecDed) -> Ded {
        Ded::LetRecDed(node)
    }
}
impl From<TryDed> for Ded {
    fn from(node: TryDed) -> Ded {
        Ded::TryDed(node)
    }
}
impl AstNode for Ded {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, METHOD_CALL_DED | BANG_METHOD_CALL_DED | ASSUME_DED | NAMED_ASSUME_DED
            | PROOF_BY_CONTRA_DED | UNIVERSAL_GENERAL_DED | EXISTENTIAL_INSTANT_DED |
            INDUCT_DED | CASES_DED | CHECK_DED | MATCH_DED | LET_DED | LET_REC_DED |
            TRY_DED
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            METHOD_CALL_DED => Ded::MethodCallDed(MethodCallDed { syntax }),
            BANG_METHOD_CALL_DED => Ded::BangMethodCallDed(BangMethodCallDed { syntax }),
            ASSUME_DED => Ded::AssumeDed(AssumeDed { syntax }),
            NAMED_ASSUME_DED => Ded::NamedAssumeDed(NamedAssumeDed { syntax }),
            PROOF_BY_CONTRA_DED => Ded::ProofByContraDed(ProofByContraDed { syntax }),
            UNIVERSAL_GENERAL_DED => {
                Ded::UniversalGeneralDed(UniversalGeneralDed { syntax })
            }
            EXISTENTIAL_INSTANT_DED => {
                Ded::ExistentialInstantDed(ExistentialInstantDed { syntax })
            }
            INDUCT_DED => Ded::InductDed(InductDed { syntax }),
            CASES_DED => Ded::CasesDed(CasesDed { syntax }),
            CHECK_DED => Ded::CheckDed(CheckDed { syntax }),
            MATCH_DED => Ded::MatchDed(MatchDed { syntax }),
            LET_DED => Ded::LetDed(LetDed { syntax }),
            LET_REC_DED => Ded::LetRecDed(LetRecDed { syntax }),
            TRY_DED => Ded::TryDed(TryDed { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Ded::MethodCallDed(it) => &it.syntax,
            Ded::BangMethodCallDed(it) => &it.syntax,
            Ded::AssumeDed(it) => &it.syntax,
            Ded::NamedAssumeDed(it) => &it.syntax,
            Ded::ProofByContraDed(it) => &it.syntax,
            Ded::UniversalGeneralDed(it) => &it.syntax,
            Ded::ExistentialInstantDed(it) => &it.syntax,
            Ded::InductDed(it) => &it.syntax,
            Ded::CasesDed(it) => &it.syntax,
            Ded::CheckDed(it) => &it.syntax,
            Ded::MatchDed(it) => &it.syntax,
            Ded::LetDed(it) => &it.syntax,
            Ded::LetRecDed(it) => &it.syntax,
            Ded::TryDed(it) => &it.syntax,
        }
    }
}
impl From<IdentPat> for RestrictedPat {
    fn from(node: IdentPat) -> RestrictedPat {
        RestrictedPat::IdentPat(node)
    }
}
impl From<AnnotatedIdentPat> for RestrictedPat {
    fn from(node: AnnotatedIdentPat) -> RestrictedPat {
        RestrictedPat::AnnotatedIdentPat(node)
    }
}
impl From<RestrictedApplyPat> for RestrictedPat {
    fn from(node: RestrictedApplyPat) -> RestrictedPat {
        RestrictedPat::RestrictedApplyPat(node)
    }
}
impl From<RestrictedNamedPat> for RestrictedPat {
    fn from(node: RestrictedNamedPat) -> RestrictedPat {
        RestrictedPat::RestrictedNamedPat(node)
    }
}
impl AstNode for RestrictedPat {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind, IDENT_PAT | ANNOTATED_IDENT_PAT | RESTRICTED_APPLY_PAT |
            RESTRICTED_NAMED_PAT
        )
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PAT => RestrictedPat::IdentPat(IdentPat { syntax }),
            ANNOTATED_IDENT_PAT => {
                RestrictedPat::AnnotatedIdentPat(AnnotatedIdentPat { syntax })
            }
            RESTRICTED_APPLY_PAT => {
                RestrictedPat::RestrictedApplyPat(RestrictedApplyPat { syntax })
            }
            RESTRICTED_NAMED_PAT => {
                RestrictedPat::RestrictedNamedPat(RestrictedNamedPat { syntax })
            }
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            RestrictedPat::IdentPat(it) => &it.syntax,
            RestrictedPat::AnnotatedIdentPat(it) => &it.syntax,
            RestrictedPat::RestrictedApplyPat(it) => &it.syntax,
            RestrictedPat::RestrictedNamedPat(it) => &it.syntax,
        }
    }
}
impl From<IdentPat> for SimplePat {
    fn from(node: IdentPat) -> SimplePat {
        SimplePat::IdentPat(node)
    }
}
impl From<WildcardPat> for SimplePat {
    fn from(node: WildcardPat) -> SimplePat {
        SimplePat::WildcardPat(node)
    }
}
impl AstNode for SimplePat {
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IDENT_PAT | WILDCARD_PAT)
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IDENT_PAT => SimplePat::IdentPat(IdentPat { syntax }),
            WILDCARD_PAT => SimplePat::WildcardPat(WildcardPat { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            SimplePat::IdentPat(it) => &it.syntax,
            SimplePat::WildcardPat(it) => &it.syntax,
        }
    }
}
impl std::fmt::Display for Sort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Phrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Dir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Pat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Ded {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestrictedPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SimplePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Identifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaIdent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Unit {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundSort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DirStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PhraseStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModuleDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DomainDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DomainsDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DeclareDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineProcDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DefineMultiDir {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundSortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SortVarsDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FuncSorts {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprPhrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DedPhrase {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TermVarExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LambdaExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ApplicationExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CellExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RefExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MakeVectorExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VectorSubExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VectorSetExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SeqExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AndExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for OrExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MethodCallDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BangMethodCallDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedAssumeDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ProofByContraDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UniversalGeneralDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExistentialInstantDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for InductDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CasesDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LetRecDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssumePart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestrictedApplyPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestrictedNamedPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnnotatedIdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RestrictedMatchDed {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CheckDedArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MatchDedArm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryDedPart {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MetaIdentPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnitPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WildcardPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NamedPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ValOfPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListOfPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SplitPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CompoundPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WherePat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SomeThingPat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SomeThing {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
