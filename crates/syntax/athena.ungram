// Athena Un-Grammar.
//
// This grammar specifies the structure of Athena's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
//
// Legend:
//
//   //          -- comment
//   Name =      -- non-terminal definition
//   'ident'     -- token (terminal)
//   A B         -- sequence
//   A | B       -- alternation
//   A*          -- zero or more repetition
//   A?          -- zero or one repetition
//   (A)         -- same as A
//   label:A     -- suggested name for field of AST node

//
// The `Tokens` non-terminal definition is special. It should consist of alternating terminals
// of the form `terminal_name = lexer_regex`. 
// These are extracted from the grammar to generate
// lexer code (using the `logos` crate) automatically. If a terminal exists in the grammar but does
// not have a definition in `Tokens` it is taken as a verbatim lexer rule. (For instance, the ':'
// terminal gets a lexer rule `#[token(":")]` instead of a regex).
//
Tokens =
    'ident = (::)|~|([%&*+\\--9<->@-Z\\\\^_a-z|](!|[#-\']|[*+]|[\\--9]|[<-\\\\]|\\^|[_-z]|\\|)*)'
    | 'string = "([ !~#-\\[\\]-~]|(?:\\\\\\d+)|(?:\\\\["\\\\abnrftv])|(?:\\\\\\^[A-Z@\\[\\]/^]))*"'
    | 'char = `([ !~#-\\[\\]-~]|(?:\\\\\\d+)|(?:\\\\["\\\\abnrftv])|(?:\\\\\\^[A-Z@\\[\\]/^]))'
    | 'whitespace = [ \\t\\n\\r]+'
    | 'comment = #.*'

Fake =
    'dtry'
    | 'dlet'
    | 'dcheck'

//********************//
// Names and Literals //
//********************//

Identifier =
    'ident'

Literal =
    'string' | 'char'

MetaIdent =
    '\'' Identifier

Unit =
    '(' ')'

MaybeTypedParam =
    Identifier
    | TypedParam
    | OpAnnotatedParam

TypedParam =
    Identifier ':' Sort

MaybeWildcardTypedParam =
    MaybeTypedParam
    | Wildcard

Wildcard =
    '_'

OpAnnotatedParam =
    Identifier ':' '(' 'OP' Identifier Identifier? ')'

//*********//
//  Misc   //
//*********//
PrefixBinding =
    '(' Pat Phrase ')'

//*******//
// Sorts //
//*******//

Sort =
    VarSort // ✅
    | IdentSort // ✅
    | CompoundSort // ✅

IdentSort =
    Identifier

VarSort =
    '\'' Identifier 

CompoundSort =
    '(' Sort* ')'

//************//
// SourceFile //
//************//

SourceFile =
    Stmt*

//************//
// Statements //
//************//

Stmt =
    DirStmt // ✅
    | PhraseStmt // ✅

PhraseStmt =
    Phrase

DirStmt =
    Dir

StructureNameDef =
    SortDecl

StructureConstructor =
    ConstantConstructor
    | CompoundConstructor

ConstantConstructor =
    Identifier

CompoundConstructor =
    '(' Identifier MaybeTaggedSortDecl ')'

MaybeTaggedSortDecl =
    (tag:Identifier ':')? SortDecl

StructureDef =
    StructureNameDef ':=' (StructureConstructor ('|' StructureConstructor)*)

DatatypeStmt =
    'datatype' StructureDef

StructureStmt =
    'structure' StructureDef

DatatypesStmt =
    'datatypes' (StructureDef ('&&' StructureDef)*)

StructuresStmt =
    'structures' (StructureDef ('&&' StructureDef)*)

//************//
// Directives //
//************//

Dir =
    ModuleDir // ✅
    | DomainDir // ✅
    | DomainsDir // ✅
    | DefineDir // ✅
    | LoadDir
    | AssertDir
    | AssertClosedDir
    | DeclareDir
    | ConstantDeclareDir
    | ExtendModuleDir
    | OpenDir
    | AssociativityDir

ModuleDir =
    InfixModuleDir
    | PrefixModuleDir

InfixModuleDir =
    'module' Identifier '{' Stmt* '}'

PrefixModuleDir =
    '(' 'module' Identifier Stmt* ')'

ExtendModuleDir =
    'extend-module' Identifier '{' Stmt* '}'

DomainDir =
    'domain' SortDecl

DomainsDir =
    'domains' (SortDecl (',' SortDecl)*)

SortDecl =
    IdentSort
    | CompoundSortDecl

CompoundSortDecl =
    '(' SortDecl* ')'

ConstantDeclareDir =
    InfixConstantDeclare
    | PrefixConstantDeclare

InfixConstantDeclare =
    'declare' (Identifier (',' Identifier)*) ':' SortDecl

PrefixConstantDeclare =
    '(' 'declare' PrefixDeclareSymbols SortDecl ')'

PrefixDeclareDir =
    '(' 'declare' PrefixDeclareSymbols '(' PrefixSortVarsDecl?  '->' '(' SortDecl* ')' SortDecl ')' PrefixDeclareAttrs? ')'

PrefixDeclareSymbols =
    PrefixSingleSymbol
    | PrefixMultiSymbols

PrefixSingleSymbol =
    Identifier

PrefixMultiSymbols =
    '(' Identifier* ')'

PrefixDeclareAttrs =
    '(' DeclareAttr* InputTransformDecl? ')'

DeclareDir =
    PrefixDeclareDir
    | InfixDeclareDir

InfixDeclareDir =
    'declare' (Identifier (',' Identifier)*) ':' SortVarsDecl? FuncSorts '->' return_sort:SortDecl DeclareAttrs?

InputTransformDecl =
    '[' Expr Expr* ']'

DeclareAttr =
    'left-assoc'
    | 'right-assoc'
    | Identifier

DeclareAttrs =
    '[' DeclareAttr* InputTransformDecl? ']'

FuncSorts =
    '[' SortDecl* ']'

SortVarsDecl =
    '(' (IdentSort (',' IdentSort)*) ')'

PrefixSortVarsDecl =
    '(' IdentSort* ')'

DefineDir =
    InfixDefineDir
    | PrefixDefineDir

PrefixDefineDir =
    PrefixDefine
    | PrefixDefineBlocks

PrefixDefine =
    '(' 'define' DefineName Phrase ')'

PrefixDefineBlocks =
    '(' 'define' PrefixDefineBlock* ')'

InfixDefineDir =
    'private'? 'define' DefineName ':=' Phrase

DefineName =
    Identifier
    | DefineNamedPattern
    | DefineProc
    | ListPat

DefineNamedPattern =
    '(' Identifier 'as' ListPat ')' 

DefineProc = 
    '(' Identifier args:MaybeWildcardTypedParam* ')'

LoadDir =
    '('? 'load' 'string' ')'? // can be surrounded by parens

AssertDir =
    'assert' (Identifier ':=')? (Expr (',' Expr)*)

AssertClosedDir =
    'assert*' (Identifier ':=')? Expr

OpenDir =
    'open' (Identifier (',' Identifier)*)

AssociativityDir =
    ('left-assoc' | 'right-assoc') Identifier

RuleDir =
    InfixRuleDir
    | PrefixRuleDir

InfixRuleDir =
    'primitive-method' '(' Identifier MaybeWildcardTypedParam* ')' ':=' Expr

PrefixRuleDir =
    '(' 'primitive-method' '(' Identifier MaybeWildcardTypedParam* ')' Expr ')'

ExpandInputDir =
    'expand-input' (Phrase (',' Phrase)*) expander:Phrase

DefineSortDir =
    'define-sort' Identifier ':=' Sort

PrefixDefineBlock =
    DefineProc ':='? Phrase

//     '(' Id MWPL* ')' Ded
//     | '(' Id ':' '(' 'OP' Id Id ')' MWPL* ')' Expr
//     | '(' Id ':' '(' 'OP' Id ')' MWPL* ')' ':='? Expr
//     | '(' Id MWPL* ')' ':='? Expr

//****************************//
// Expressions and Deductions //
//****************************//

Phrase =
    ExprPhrase
    | DedPhrase

ExprPhrase = 
    Expr

DedPhrase =
    Ded

Expr =
    IdentExpr // ✅
    | LiteralExpr // ✅
    | UnitExpr // ✅
    | TermVarExpr // ✅
    | MetaIdent // ✅
    | CheckExpr // ✅
    | LambdaExpr // ✅
    | ApplicationExpr // ✅
    | ListExpr // ✅
    | MethodExpr
    | LetExpr // ✅
    | LetRecExpr // ✅
    | MatchExpr // ✅
    | TryExpr // ✅
    | CellExpr // ✅
    | SetExpr // ✅
    | RefExpr // ✅
    | WhileExpr // ✅
    | MakeVectorExpr // ✅
    | VectorSubExpr // ✅
    | VectorSetExpr // ✅
    | SeqExpr // ✅
    | AndExpr // ✅
    | OrExpr // ✅
    | MapExpr
    | WildcardExpr
    | PrefixCheckExpr

IdentExpr =
    MaybeTypedParam

LiteralExpr =
    Literal

UnitExpr =
    '(' ')'

MetaIdentExpr =
    MetaIdent

TermVarExpr =
    '?' Identifier (':' Sort)?

WildcardExpr =
    '_'

CheckExpr =
    'check' '{' CheckArm* '}'

CheckArm = 
    '|'? Phrase '=>' Expr

PrefixCheckExpr =
    '(' 'check' CheckClause* ')'

CheckClause =
    '(' Phrase Expr ')'

LambdaExpr =
    'lambda' '(' MaybeWildcardTypedParam* ')' Expr

ApplicationExpr =
    '(' Expr Phrase* ')'

ListExpr =
    '[' Phrase* ']'

MethodExpr =
    'method' '(' MaybeWildcardTypedParam* ')' Ded

PrefixLetExpr =
    '(' 'let' '(' PrefixBinding* ')' Expr ')' 

LetExpr =
    'let' '{' LetPart* '}' Expr

PrefixLetRecExpr =
    '(' 'letrec' '(' PrefixBinding* ')' Expr ')'

LetRecExpr =
    'letrec' '{' LetRecPart* '}' Expr

MatchExpr =
    InfixMatchExpr
    | PrefixMatchExpr

InfixMatchExpr =
    'match' Phrase '{' arms:MatchArm* '}'

PrefixMatchExpr =
    '(' 'match' Phrase clauses:MatchClause* ')'

MatchArm = 
    '|'? Pat '=>' Expr

MatchClause =
    '(' Pat Expr ')'

TryExpr =
    'try' '{' TryArm* '}'

TryArm =
    '|'? Expr

PrefixTryExpr =
    '(' 'try' Expr* ')' // TODO: validation of >=1 expr

CellExpr =
    'cell' Phrase

SetExpr =
    'set!' Expr Phrase

RefExpr =
    'ref' Expr

WhileExpr =
    'while' Phrase Expr

MakeVectorExpr =
    'make-vector' Expr Phrase

VectorSubExpr =
    'vector-sub' Expr Expr

VectorSetExpr =
    'vector-set!' Expr Expr Phrase

SeqExpr =
    '(' 'seq' Phrase* ')'

AndExpr =
    '(' '&&' Phrase* ')' // also can be infix but it doesn't affect the tree

OrExpr =
    '(' '||' Phrase* ')' // also can be infix but it doesn't affect the tree

MapExpr =
    '|{' (MapBinding (',' MapBinding)*) '}|'

MapBinding =
    Phrase ':=' Phrase

//************//
// Deductions //
//************//

Ded = 
    MethodCallDed // ✅
    | BangMethodCallDed // ✅
    | AssumeDed // ✅
    | NamedAssumeDed // ✅
    | ProofByContraDed // ✅
    | GeneralizeOverDed // ✅
    | PickAnyDed // ✅
    | WithWitnessDed // ✅
    | PickWitnessDed // ✅
    | PickWitnessesDed // ✅
    | InductDed // ✅
    | CasesDed // ✅
    | CheckDed // ✅
    | MatchDed // ✅
    | LetDed // ✅
    | LetRecDed // ✅
    | TryDed // ✅
    | ConcludeDed
    | InferBlockDed
    | PrefixAssumeDed

ConcludeDed =
    'conclude' (Identifier ':=')? Expr Ded

MethodCallDed =
    '(' 'apply-method' Expr Phrase* ')'

BangMethodCallDed =
    '(' '!' Expr Phrase* ')'

AssumeDed =
    'assume' Phrase Ded

NamedAssumeDed =
    'assume' AssumePart* Ded

AssumePart =
    ';'? Identifier ':=' Phrase

PrefixAssumeDed =
    PrefixNamedAssumeDed
    | PrefixSingleAssumeDed
    | PrefixAssumeLetDed

PrefixNamedAssumeDed =
    '(' 'assume' Identifier ':=' Phrase Ded ')'

PrefixSingleAssumeDed =
    '(' 'assume' Phrase Ded ')'

PrefixAssumeLetDed =
    '(' 'assume-let' PrefixBinding Ded ')'

ProofByContraDed =
    'suppose-absurd' Phrase Ded

GeneralizeOverDed =
    'generalize-over' Expr Ded

PickAnyDed =
    '('? 'pick-any' MaybeTypedParam* Ded ')'?

WithWitnessDed =
    'with-witness' Expr Phrase Ded

PickWitnessDed =
    'pick-witness' Identifier 'for' Phrase Identifier? Ded

PickWitnessesDed =
    'pick-witnesses' Identifier Identifier* 'for' Phrase Identifier? Ded

InductDed =
    'by-induction' Phrase '{' RestrictedMatchDed* '}'

RestrictedMatchDed =
    '|'? Pat '=>' Ded

CasesDed =
    'datatype-cases' Phrase ('on' Expr)? '{' RestrictedMatchDed* '}'

CheckDed =
    'check' '{' arms:CheckDedArm* '}'

CheckDedArm =
    '|'? Phrase '=>' Ded

MatchDed =
    InfixMatchDed
    | PrefixMatchDed

InfixMatchDed =
    'match' Phrase '{' arms:MatchDedArm* '}'

PrefixMatchDed =
    '(' 'dmatch' Phrase clauses:MatchDedClause* ')'

MatchDedClause = 
    '(' Pat Ded ')'

MatchDedArm =
    '|'? Pat '=>' Ded

InfixLetDed =
    'let' '{' LetPart* '}' Ded

LetPart =
    ';'? Pat ':=' Phrase

InfixLetRecDed =
    'letrec' '{' LetRecPart* '}' Ded

LetDed = 
    InfixLetDed
    | PrefixLetDed

LetRecDed = 
    InfixLetRecDed
    | PrefixLetRecDed

PrefixLetDed =
    '(' 'dlet' '(' PrefixBinding* ')' Ded ')'

PrefixLetRecDed =
    '(' 'dletrec' '(' PrefixBinding* ')' Ded ')'

LetRecPart = 
    ';'? Identifier ':=' Expr

TryDed =
    InfixTryDed
    | PrefixTryDed

InfixTryDed =
    'try' '{' TryDedArm* '}'

PrefixTryDed =
    '(' 'dtry' Ded* ')'

TryDedArm =
    '|'? Ded

InferBlockDed =
    ('{' | 'begin') (MaybeNamedInference (';' MaybeNamedInference )*) ('}' | 'end')

MaybeNamedInference =
    (MaybeWildcardOpAnnotatedParam ':=')? InferOrExpr

InferOrExpr =
    Inference
    | Expr

MaybeWildcardOpAnnotatedParam =
    '_'
    | OpAnnotatedParam
    | Identifier

Inference =
    InferFrom
    | InferBy
    | Ded

InferFrom =
    Expr 'from' (Phrase (',' Phrase)*)

InferBy =
    Expr ('by' by_expr:Expr)? 'on' (Phrase (',' Phrase)*)

ByDed =
    '(' Phrase 'by' Ded ')' 

//**********//
// Patterns //
//**********//

Pat =
    IdentPat // ✅
    | VarPat // ✅
    | MetaIdentPat // ✅
    | LiteralPat // ✅
    | UnitPat // ✅
    | NamedPat // ✅
    | ValOfPat // ✅
    | ListOfPat // ✅
    | SplitPat // ✅
    | ListPat // ✅
    | CompoundPat // ✅
    | WherePat // ✅
    | SomeThingPat // ✅

IdentPat =
    MaybeWildcardTypedParam

VarPat =
    '?' Identifier ':' Sort

LiteralPat =
    Literal

MetaIdentPat =
    MetaIdent

UnitPat =
    Unit

NamedPat =
    '(' ('bind' | 'as') Identifier Pat ')'
    | '(' Identifier ('bind' | 'as') Pat ')'

ValOfPat =
    '(' 'val-of' Identifier ')'

ListOfPat =
    '(' 'list-of' Pat Pat ')'

SplitPat =
    '(' 'split' first:Pat second:Pat rest:Pat* ')'

ListPat =
    '[' Pat* ']'

CompoundPat =
    '(' Pat* ')'

WherePat =
    '(' Pat 'where' Expr ')'

OrPat =
    '(' '||' Pat* ')'

SomeThing =
    'some-var'
    | 'some-sent-con'
    | 'some-quant'
    | 'some-term'
    | 'some-atom'
    | 'some-sentence'
    | 'some-list'
    | 'some-cell'
    | 'some-vector'
    | 'some-proc'
    | 'some-method'
    | 'some-symbol'
    | 'some-table'
    | 'some-map'
    | 'some-sub'
    | 'some-char'

SomeThingPat =
    '(' SomeThing IdentPat ')'