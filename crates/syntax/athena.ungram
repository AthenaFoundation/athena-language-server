// Athena Un-Grammar.
//
// This grammar specifies the structure of Athena's concrete syntax tree.
// It does not specify parsing rules (ambiguities, precedence, etc are out of scope).
// Tokens are processed -- contextual keywords are recognised, compound operators glued.
//
//
// Legend:
//
//   //          -- comment
//   Name =      -- non-terminal definition
//   'ident'     -- token (terminal)
//   A B         -- sequence
//   A | B       -- alternation
//   A*          -- zero or more repetition
//   A?          -- zero or one repetition
//   (A)         -- same as A
//   label:A     -- suggested name for field of AST node

//
// The `Tokens` non-terminal definition is special. It should consist of alternating terminals
// of the form `terminal_name = lexer_regex`. 
// These are extracted from the grammar to generate
// lexer code (using the `logos` crate) automatically. If a terminal exists in the grammar but does
// not have a definition in `Tokens` it is taken as a verbatim lexer rule. (For instance, the ':'
// terminal gets a lexer rule `#[token(":")]` instead of a regex).
//
Tokens =
    'ident = (::)|~|([%&*+\\--9<->@-Z\\\\^_a-z|](!|[#-\']|[*+]|[\\--9]|[<-\\\\]|\\^|[_-z]|\\|)*)'
    | 'string = "([ ~#-\\[\\]-~]|(?:\\\\\\d+)|(?:\\\\["\\\\abnrftv])|(?:\\\\\\^[A-Z@\\[\\]/^]))*"'
    | 'char = `([ ~#-\\[\\]-~]|(?:\\\\\\d+)|(?:\\\\["\\\\abnrftv])|(?:\\\\\\^[A-Z@\\[\\]/^]))'
    | 'whitespace = [ \\t\\n\\r]+'
    | 'comment = #.*'

//********************//
// Names and Literals //
//********************//

Identifier =
    'ident'

Literal =
    'string' | 'char'

MetaIdent =
    '\'' Identifier

Unit =
    '(' ')'

MaybeTypedParam =
    Identifier
    | TypedParam
    | OpAnnotatedParam

TypedParam =
    Identifier ':' Sort

MaybeWildcardTypedParam =
    MaybeTypedParam
    | '_'

OpAnnotatedParam =
    Identifier ':' '(' 'OP' Identifier Identifier? ')'

//*******//
// Sorts //
//*******//

Sort =
    VarSort // ✅
    | IdentSort // ✅
    | CompoundSort // ✅

IdentSort =
    Identifier

VarSort =
    '\'' Identifier 

CompoundSort =
    '(' Sort* ')'

//************//
// SourceFile //
//************//

SourceFile =
    Stmt*

//************//
// Statements //
//************//

Stmt =
    DirStmt // ✅
    | PhraseStmt // ✅

PhraseStmt =
    Phrase

DirStmt =
    Dir

StructureNameDef =
    SortDecl

StructureConstructor =
    ConstantConstructor
    | CompoundConstructor

ConstantConstructor =
    Identifier

CompoundConstructor =
    '(' Identifier MaybeTaggedSortDecl ')'

MaybeTaggedSortDecl =
    (tag:Identifier ':')? SortDecl

StructureDef =
    StructureNameDef ':=' (StructureConstructor ('|' StructureConstructor)*)

DatatypeStmt =
    'datatype' StructureDef

StructureStmt =
    'structure' StructureDef

DatatypesStmt =
    'datatypes' (StructureDef ('&&' StructureDef)*)

StructuresStmt =
    'structures' (StructureDef ('&&' StructureDef)*)

//************//
// Directives //
//************//

Dir =
    ModuleDir // ✅
    | DomainDir // ✅
    | DomainsDir // ✅
    | DefineDir // ✅
    | LoadDir
    | AssertDir
    | AssertClosedDir
    | DeclareDir
    | ConstantDeclareDir
    | ExtendModuleDir
    | OpenDir
    | AssociativityDir

ModuleDir =
    InfixModuleDir
    | PrefixModuleDir

InfixModuleDir =
    'module' Identifier '{' Stmt* '}'

PrefixModuleDir =
    '(' 'module' Identifier Stmt* ')'

ExtendModuleDir =
    'extend-module' Identifier '{' Stmt* '}'

DomainDir =
    'domain' SortDecl

DomainsDir =
    'domains' (SortDecl (',' SortDecl)*)

SortDecl =
    IdentSort
    | CompoundSortDecl

CompoundSortDecl =
    '(' SortDecl* ')'

ConstantDeclareDir =
    'declare' (Identifier (',' Identifier)*) ':' SortDecl

DeclareDir =
    'declare' (Identifier (',' Identifier)*) ':' SortVarsDecl? FuncSorts '->' return_sort:SortDecl DeclareAttrs?

InputTransformDecl =
    '[' Expr Expr* ']'

DeclareAttr =
    'left-assoc'
    | 'right-assoc'
    | Identifier

DeclareAttrs =
    '[' DeclareAttr* InputTransformDecl? ']'

FuncSorts =
    '[' SortDecl* ']'

SortVarsDecl =
    '(' (IdentSort (',' IdentSort)*) ')'

DefineDir =
    InfixDefineDir
    | PrefixDefineDir

PrefixDefineDir =
    '(' 'define' Identifier Phrase ')'

InfixDefineDir =
    'private'? 'define' DefineName ':=' Phrase

DefineName =
    Identifier
    | DefineNamedPattern
    | DefineProc
    | ListPat

DefineNamedPattern =
    '(' Identifier 'as' ListPat ')' 

DefineProc = 
    '(' Identifier args:MaybeWildcardTypedParam* ')'

LoadDir =
    'load' 'string'

AssertDir =
    'assert' (Identifier ':=')? (Expr (',' Expr)*)

AssertClosedDir =
    'assert*' (Identifier ':=')? Expr

OpenDir =
    'open' (Identifier (',' Identifier)*)

AssociativityDir =
    ('left-assoc' | 'right-assoc') Identifier

//****************************//
// Expressions and Deductions //
//****************************//

Phrase =
    ExprPhrase
    | DedPhrase

ExprPhrase = 
    Expr

DedPhrase =
    Ded

Expr =
    IdentExpr // ✅
    | LiteralExpr // ✅
    | UnitExpr // ✅
    | TermVarExpr // ✅
    | MetaIdent // ✅
    | CheckExpr // ✅
    | LambdaExpr // ✅
    | ApplicationExpr // ✅
    | ListExpr // ✅
    | MethodExpr
    | LetExpr // ✅
    | LetRecExpr // ✅
    | MatchExpr // ✅
    | TryExpr // ✅
    | CellExpr // ✅
    | SetExpr // ✅
    | RefExpr // ✅
    | WhileExpr // ✅
    | MakeVectorExpr // ✅
    | VectorSubExpr // ✅
    | VectorSetExpr // ✅
    | SeqExpr // ✅
    | AndExpr // ✅
    | OrExpr // ✅
    | MapExpr
    | WildcardExpr

IdentExpr =
    MaybeTypedParam

LiteralExpr =
    Literal

UnitExpr =
    '(' ')'

MetaIdentExpr =
    MetaIdent

TermVarExpr =
    '?' Identifier (':' Sort)?

WildcardExpr =
    '_'

CheckExpr =
    'check' '{' CheckArm*  '}'

CheckArm = 
    '|'? Phrase '=>' Expr

LambdaExpr =
    'lambda' '(' Identifier* ')' Expr

ApplicationExpr =
    '(' Expr Phrase* ')'

ListExpr =
    '[' Phrase* ']'

MethodExpr =
    'method' '(' Identifier* ')' Ded

LetExpr =
    'let' '{' LetPart* '}' Expr

LetRecExpr =
    'letrec' '{' LetRecPart* '}' Expr

MatchExpr =
    'match' Phrase '{' arms:MatchArm* '}'

MatchArm = 
    '|'? Pat '=>' Expr

TryExpr =
    'try' '{' TryArm* '}'

TryArm =
    '|'? Expr

CellExpr =
    'cell' Phrase

SetExpr =
    'set!' Expr Phrase

RefExpr =
    'ref' Expr

WhileExpr =
    'while' Phrase Expr

MakeVectorExpr =
    'make-vector' Expr Phrase

VectorSubExpr =
    'vector-sub' Expr Expr

VectorSetExpr =
    'vector-set!' Expr Expr Phrase

SeqExpr =
    '(' 'seq' Phrase* ')'

AndExpr =
    '(' '&&' Phrase* ')'

OrExpr =
    '(' '||' Phrase* ')'

MapExpr =
    '|{' (MapBinding (',' MapBinding)*) '}|'

MapBinding =
    Phrase ':=' Phrase

//************//
// Deductions //
//************//

Ded = 
    MethodCallDed // ✅
    | BangMethodCallDed // ✅
    | AssumeDed // ✅
    | NamedAssumeDed // ✅
    | ProofByContraDed // ✅
    | GeneralizeOverDed // ✅
    | PickAnyDed // ✅
    | WithWitnessDed // ✅
    | PickWitnessDed // ✅
    | PickWitnessesDed // ✅
    | InductDed // ✅
    | CasesDed // ✅
    | CheckDed // ✅
    | MatchDed // ✅
    | LetDed // ✅
    | LetRecDed // ✅
    | TryDed // ✅
    | ConcludeDed
    | InferBlockDed

ConcludeDed =
    'conclude' (Identifier ':=')? Expr Ded

MethodCallDed =
    '(' 'apply-method' Expr Phrase* ')'

BangMethodCallDed =
    '(' '!' Expr Phrase* ')'

AssumeDed =
    'assume' Phrase Ded

NamedAssumeDed =
    'assume' AssumePart* Ded

AssumePart =
    ';'? Identifier ':=' Phrase

ProofByContraDed =
    'suppose-absurd' Phrase Ded

GeneralizeOverDed =
    'generalize-over' Expr Ded

PickAnyDed =
    'pick-any' MaybeTypedParam* Ded

WithWitnessDed =
    'with-witness' Expr Phrase Ded

PickWitnessDed =
    'pick-witness' Identifier 'for' Phrase Identifier? Ded

PickWitnessesDed =
    'pick-witnesses' Identifier Identifier* 'for' Phrase Identifier? Ded

RestrictedApplyPat =
    '(' Identifier RestrictedPat RestrictedPat* ')'

RestrictedNamedPat =
    '(' Identifier 'as' RestrictedPat ')'

RestrictedPat =
    IdentPat
    | RestrictedApplyPat
    | RestrictedNamedPat

InductDed =
    'by-induction' Phrase '{' RestrictedMatchDed* '}'

RestrictedMatchDed =
    '|'? RestrictedPat '=>' Ded

CasesDed =
    'datatype-cases' Phrase ('on' Expr)? '{' RestrictedMatchDed* '}'

CheckDed =
    'check' '{' arms:CheckDedArm* '}'

CheckDedArm =
    '|'? Phrase '=>' Ded

MatchDed =
    'match' Phrase '{' arms:MatchDedArm* '}'

MatchDedArm =
    '|'? Pat '=>' Ded

LetDed =
    'let' '{' LetPart* '}' Ded

LetPart =
    ';'? Pat ':=' Phrase

LetRecDed =
    'letrec' '{' LetRecPart* '}' Ded

LetRecPart = 
    ';'? Identifier ':=' Expr

TryDed =
    'try' '{' TryDedArm* '}'

TryDedArm =
    '|'? Ded

InferBlockDed =
    ('{' | 'begin') (MaybeNamedInference (';' MaybeNamedInference )*) ('}' | 'end')

MaybeNamedInference =
    (MaybeWildcardOpAnnotatedParam ':=')? Inference

MaybeWildcardOpAnnotatedParam =
    '_'
    | OpAnnotatedParam
    | Identifier

Inference =
    InferFrom
    | InferBy
    | Ded

InferFrom =
    Expr 'from' (Phrase (',' Phrase)*)

InferBy =
    Expr ('by' by_expr:Expr)? 'on' (Phrase (',' Phrase)*)

ByDed =
    '(' Expr 'by' Ded ')' 

//**********//
// Patterns //
//**********//

Pat =
    IdentPat // ✅
    | VarPat // ✅
    | MetaIdentPat // ✅
    | LiteralPat // ✅
    | UnitPat // ✅
    | WildcardPat // ✅
    | NamedPat // ✅
    | ValOfPat // ✅
    | ListOfPat // ✅
    | SplitPat // ✅
    | ListPat // ✅
    | CompoundPat // ✅
    | WherePat // ✅
    | SomeThingPat // ✅

IdentPat =
    MaybeTypedParam

VarPat =
    '?' Identifier ':' Sort

LiteralPat =
    Literal

MetaIdentPat =
    MetaIdent

UnitPat =
    Unit

WildcardPat = 
    '_'

NamedPat =
    '(' 'bind' Identifier Pat ')'
    | '(' Identifier 'as' Pat ')'

ValOfPat =
    '(' 'val-of' Identifier ')'

ListOfPat =
    '(' 'list-of' Pat Pat ')'

SplitPat =
    '(' 'split' Pat Pat ')'

SimplePat =
    IdentPat
    | WildcardPat

ListPat =
    '[' Pat* ']'

CompoundPat =
    '(' Pat* ')'

WherePat =
    '(' Pat 'where' Expr ')'

OrPat =
    '(' '||' Pat* ')'

SomeThing =
    'some-var'
    | 'some-sent-con'
    | 'some-quant'
    | 'some-term'
    | 'some-atom'
    | 'some-sentence'
    | 'some-list'
    | 'some-cell'
    | 'some-vector'
    | 'some-proc'
    | 'some-method'
    | 'some-symbol'
    | 'some-table'
    | 'some-map'
    | 'some-sub'
    | 'some-char'

SomeThingPat =
    '(' SomeThing SimplePat ')'